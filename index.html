<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pirate Survivor Prototype</title>
  <style>
    html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; background: #071521; color: #e8f5ff; font-family: system-ui, sans-serif; }
    .wrap { position: fixed; inset: 0; }
    canvas { display: block; width: 100vw; height: 100vh; border: 0; background: radial-gradient(circle at 30% 30%, #0a2a3f, #071521 70%); }
    .hud { position: absolute; top: 10px; left: 14px; right: 14px; z-index: 5; display: flex; justify-content: space-between; font-size: 14px; pointer-events: none; }
    .hint { position: absolute; left: 14px; right: 14px; bottom: 12px; z-index: 5; color: #9fc2d9; font-size: 13px; text-align: center; pointer-events: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="stats"></div>
      <div id="wind"></div>
    </div>
    <canvas id="game" width="1280" height="720"></canvas>
    <div class="hint">Steer: A/D · Row forward: W · Brake/anchor drag: S · Toggle sail: E · Mouse wheel zoom · Level-up: 1/2/3</div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const statsEl = document.getElementById('stats');
const windEl = document.getElementById('wind');

function resizeCanvas() {
  const w = Math.max(900, window.innerWidth);
  const h = Math.max(540, window.innerHeight);
  canvas.width = w;
  canvas.height = h;
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const keys = new Set();
window.addEventListener('keydown', (e) => keys.add(e.key.toLowerCase()));
window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'e' && !e.repeat) {
    player.sailOpen = !player.sailOpen;
  }
});

window.addEventListener('wheel', (e) => {
  e.preventDefault();
  const step = e.deltaY > 0 ? -0.06 : 0.06;
  state.zoomUserOffset = clamp(state.zoomUserOffset + step, -0.26, 0.62);
}, { passive: false });

const ENDLESS_MODE = true;
const LEVEL_CONFIGS = [
  { name: 'Coastal Skirmish', duration: 45, spawnRate: 1.0, bossEvery: 45, windShift: 16 },
  { name: 'Open Waters', duration: 55, spawnRate: 1.2, bossEvery: 50, windShift: 14 },
  { name: 'Storm Belt', duration: 65, spawnRate: 1.45, bossEvery: 55, windShift: 11 },
  { name: 'Kraken Frontier', duration: 75, spawnRate: 1.75, bossEvery: 60, windShift: 9 }
];

function getLevelConfig(stageIndex) {
  if (stageIndex < LEVEL_CONFIGS.length) {
    return LEVEL_CONFIGS[stageIndex];
  }

  const tail = LEVEL_CONFIGS[LEVEL_CONFIGS.length - 1];
  const extra = stageIndex - LEVEL_CONFIGS.length + 1;

  return {
    name: `Endless ${extra}`,
    duration: Math.max(45, tail.duration - extra * 2),
    spawnRate: tail.spawnRate + extra * 0.22,
    bossEvery: Math.max(38, tail.bossEvery - extra),
    windShift: Math.max(6, tail.windShift - Math.floor(extra * 0.4))
  };
}

const state = {
  time: 0,
  gold: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  stageIndex: 0,
  stageTimer: 0,
  difficultyTier: 0,
  bossTimer: 0,
  bossesDefeated: 0,
  enemies: [],
  bullets: [],
  drops: [],
  particles: [],
  gameOver: false,
  upgradesOffered: null,
  wind: { x: 0.35, y: -0.12, timer: 0 },
  world: { width: 3600, height: 2600 },
  camera: { x: 0, y: 0 },
  zoom: 1,
  rowEffort: 0,
  difficultyFromSize: 0,
  defenseTier: 0,
  zoomUserOffset: 0,
  islands: [],
  clouds: []
};

const player = {
  x: 1800,
  y: 1300,
  hp: 100,
  maxHp: 100,
  size: 16,
  heading: -Math.PI / 2,
  speed: 0,
  baseSpeed: 2.6,
  gunReload: 1.35,
  cannonReload: 2.2,
  gunTimer: 1.35,
  cannonTimer: 2.2,
  bulletDamage: 9,
  bulletSpeed: 6,
  rowers: 0,
  gunners: 2,
  cannons: 0,
  cannonPivot: 0,
  crew: 2,
  rudder: 0,
  sailOpen: true,
  ram: false,
  ramDamage: 46,
  mass: 28,
  hullLength: 1,
  hullBeam: 1,
  bowSharpness: 1,
  sternTaper: 1,
  slots: [],
  hullColor: '#5f4630',
  sailColor: '#f0f7ff',
  mastScale: 1,
  trimColor: '#d9b78d'
};

function getPlayerRanges() {
  const gun = 128 + player.gunners * 7 + state.level * 0.8;
  const cannon = 236 + player.cannons * 20 + player.cannonPivot * 1.6 + state.level * 1.2;
  return {
    gun,
    cannon: Math.max(gun + 70, cannon)
  };
}

const upgradePool = [
  {
    name: 'Crew Musketeers',
    desc: '+1 crew, faster fire',
    apply() {
      player.crew += 1;
      player.gunners += 1;
      player.gunReload = Math.max(0.75, player.gunReload - 0.05);
      player.hullLength += 0.03;
      player.bowSharpness += 0.04;
      addAbility('Musketeers');
    }
  },
  {
    name: 'Cannons',
    desc: '+1 cannon, +damage',
    apply() {
      player.cannons += 1;
      player.bulletDamage += 3;
      player.cannonReload = Math.max(1.0, player.cannonReload - 0.1);
      player.hullBeam += 0.03;
      addAbility('Cannons');
    }
  },
  {
    name: 'Rowers',
    desc: '+1 rower, wind mitigation',
    apply() {
      player.rowers += 1;
      player.baseSpeed += 0.16;
      player.hullLength += 0.02;
      addAbility('Rowers');
    }
  },
  {
    name: 'Reinforced Hull',
    desc: '+15 max HP and heal 10',
    apply() {
      player.maxHp += 15;
      player.hp = Math.min(player.maxHp, player.hp + 10);
      player.hullBeam += 0.05;
      player.sternTaper -= 0.03;
      addAbility('Hull');
    }
  },
  {
    name: 'Ram Bow',
    desc: 'Ramming enabled, +size',
    apply() {
      player.ram = true;
      player.size += 2;
      player.bowSharpness += 0.14;
      addAbility('Ram');
    }
  },
  {
    name: 'Sail Mastery',
    desc: '+speed, bigger ship',
    apply() {
      player.baseSpeed += 0.25;
      player.size += 1;
      player.mass += 2;
      player.hullLength += 0.05;
      player.hullBeam -= 0.03;
      addAbility('Sails');
    }
  },
  {
    name: 'Rudder Upgrade',
    desc: 'Turn faster under momentum',
    apply() {
      player.rudder += 1;
      addAbility('Rudder');
    }
  },
  {
    name: 'Cannon Trunnions',
    desc: 'Cannons can auto-pivot +5°',
    apply() {
      player.cannonPivot = Math.min(20, player.cannonPivot + 5);
      addAbility('PivotCannons');
    }
  }
];

const majorUpgradePool = [
  {
    name: 'Dreadnought Hull',
    desc: 'Massive hull growth, +40 max HP',
    apply() {
      player.size += 5;
      player.maxHp += 40;
      player.hp = Math.min(player.maxHp, player.hp + 28);
      player.mass += 10;
      player.hullBeam += 0.12;
      player.sternTaper -= 0.06;
      player.hullColor = '#3f2f24';
      player.trimColor = '#c7a476';
      addAbility('Dreadnought');
    }
  },
  {
    name: 'Crimson Sails',
    desc: 'Faster ship, faster volleys',
    apply() {
      player.baseSpeed += 0.45;
      player.gunReload = Math.max(0.8, player.gunReload - 0.04);
      player.cannonReload = Math.max(0.9, player.cannonReload - 0.1);
      player.hullLength += 0.08;
      player.hullBeam -= 0.06;
      player.bowSharpness += 0.08;
      player.sailColor = '#d34d4d';
      player.mastScale += 0.2;
      addAbility('CrimsonSails');
    }
  },
  {
    name: 'Grand Broadside',
    desc: '+2 cannons, +10 damage',
    apply() {
      player.cannons += 2;
      player.bulletDamage += 10;
      player.size += 1;
      player.mass += 3;
      player.hullBeam += 0.08;
      addAbility('Broadside');
    }
  },
  {
    name: 'Iron Ram Prow',
    desc: 'Deadlier collisions, ram visual',
    apply() {
      player.ram = true;
      player.ramDamage += 38;
      player.size += 2;
      player.mass += 4;
      player.bowSharpness += 0.18;
      player.hullLength += 0.06;
      player.hullColor = '#4a3a2e';
      addAbility('IronRam');
    }
  }
];

function addAbility(label) {
  if (player.slots.length < 4 && !player.slots.includes(label)) {
    player.slots.push(label);
  }
}

function initWorld() {
  const islandCount = 24;
  for (let i = 0; i < islandCount; i++) {
    const x = 200 + Math.random() * (state.world.width - 400);
    const y = 200 + Math.random() * (state.world.height - 400);
    const roll = Math.random();
    const isSmall = roll < 0.22;
    const isLong = roll >= 0.22 && roll < 0.5;
    const isLarge = roll > 0.84;
    const r = isSmall ? (28 + Math.random() * 36) : isLarge ? (96 + Math.random() * 82) : (50 + Math.random() * 76);
    const island = { x, y, r, patches: [], buildings: [], defenseLevel: 0 };

    const patchCount = isSmall ? (5 + Math.floor(Math.random() * 4)) : isLarge ? (18 + Math.floor(Math.random() * 12)) : (9 + Math.floor(Math.random() * 10));
    const spineDir = Math.random() * Math.PI * 2;
    const spineLength = isLong ? (r * (1.6 + Math.random() * 1.4)) : (r * (0.4 + Math.random() * 0.5));
    const thickness = isLong ? (0.22 + Math.random() * 0.18) : (0.45 + Math.random() * 0.28);
    let maxExtent = r;

    for (let p = 0; p < patchCount; p++) {
      const t = patchCount <= 1 ? 0.5 : (p / (patchCount - 1));
      const along = (t - 0.5) * spineLength;
      const lateral = (Math.random() - 0.5) * r * thickness;
      const px = x + Math.cos(spineDir) * along - Math.sin(spineDir) * lateral + (Math.random() - 0.5) * r * 0.22;
      const py = y + Math.sin(spineDir) * along + Math.cos(spineDir) * lateral + (Math.random() - 0.5) * r * 0.22;
      const size = (isSmall ? 8 : isLarge ? 14 : 10) + Math.random() * (isLarge ? 22 : 16);
      const sides = Math.random() < 0.58 ? 6 : 3;
      const rot = Math.random() * Math.PI * 2;
      island.patches.push({ x: px, y: py, size, sides, rot });
      maxExtent = Math.max(maxExtent, Math.hypot(px - x, py - y) + size * 1.2);

      if (Math.random() < 0.35) {
        const offAng = Math.random() * Math.PI * 2;
        const offDist = size * (0.4 + Math.random() * 0.7);
        const sx = px + Math.cos(offAng) * offDist;
        const sy = py + Math.sin(offAng) * offDist;
        const ssize = size * (0.45 + Math.random() * 0.4);
        const ssides = Math.random() < 0.5 ? 6 : 3;
        island.patches.push({ x: sx, y: sy, size: ssize, sides: ssides, rot: rot + Math.random() * 0.6 });
        maxExtent = Math.max(maxExtent, Math.hypot(sx - x, sy - y) + ssize * 1.2);
      }
    }

    if (isLarge && Math.random() < 0.55) {
      const subCount = 5 + Math.floor(Math.random() * 5);
      for (let s = 0; s < subCount; s++) {
        const ang = Math.random() * Math.PI * 2;
        const dist = r * (0.65 + Math.random() * 0.35);
        const px = x + Math.cos(ang) * dist;
        const py = y + Math.sin(ang) * dist;
        const size = 12 + Math.random() * 18;
        const sides = Math.random() < 0.5 ? 6 : 3;
        const rot = Math.random() * Math.PI * 2;
        island.patches.push({ x: px, y: py, size, sides, rot });
        maxExtent = Math.max(maxExtent, Math.hypot(px - x, py - y) + size * 1.2);
      }
    }

    island.r = maxExtent;

    const bCount = Math.max(2, Math.floor(island.r / 24));
    for (let b = 0; b < bCount; b++) {
      const patch = island.patches[Math.floor(Math.random() * island.patches.length)];
      const bx = patch.x + (Math.random() - 0.5) * patch.size * 0.6;
      const by = patch.y + (Math.random() - 0.5) * patch.size * 0.6;
      const size = 8 + Math.random() * 18;
      island.buildings.push({
        x: bx,
        y: by,
        size,
        hp: 18 + size * 1.6,
        maxHp: 18 + size * 1.6,
        tower: false,
        fireTimer: Math.random()
      });
    }

    state.islands.push(island);
  }

  for (let i = 0; i < 11; i++) {
    state.clouds.push({
      x: Math.random() * state.world.width,
      y: Math.random() * state.world.height,
      w: 130 + Math.random() * 180,
      h: 45 + Math.random() * 60,
      drift: 0.2 + Math.random() * 0.35
    });
  }
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function polygonPath(cx, cy, radius, sides, rot) {
  ctx.beginPath();
  for (let i = 0; i < sides; i++) {
    const a = rot + (i / sides) * Math.PI * 2;
    const px = cx + Math.cos(a) * radius;
    const py = cy + Math.sin(a) * radius;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
}

function angleDiff(a, b) {
  return Math.atan2(Math.sin(a - b), Math.cos(a - b));
}

function updateCamera() {
  const viewW = canvas.width / state.zoom;
  const viewH = canvas.height / state.zoom;
  state.camera.x = clamp(player.x - viewW / 2, 0, Math.max(0, state.world.width - viewW));
  state.camera.y = clamp(player.y - viewH / 2, 0, Math.max(0, state.world.height - viewH));
}

function toScreen(wx, wy) {
  return {
    x: (wx - state.camera.x) * state.zoom,
    y: (wy - state.camera.y) * state.zoom
  };
}

function ensureIslandDefenses() {
  const targetTier = Math.floor((state.difficultyTier + state.difficultyFromSize) / 2);
  if (targetTier <= state.defenseTier) return;
  state.defenseTier = targetTier;

  for (const island of state.islands) {
    const towerChance = clamp(0.18 + targetTier * 0.08, 0.18, 0.85);
    island.defenseLevel = targetTier;
    for (const b of island.buildings) {
      if (!b.tower && Math.random() < towerChance) {
        b.tower = true;
        b.hp += 14 + targetTier * 4;
        b.maxHp = b.hp;
      }
    }
  }
}

function simulateVessel(entity, dt, input) {
  const fwd = { x: Math.cos(entity.heading), y: Math.sin(entity.heading) };
  const windMag = Math.hypot(state.wind.x, state.wind.y) || 1;
  const windDir = { x: state.wind.x / windMag, y: state.wind.y / windMag };

  const rowPower = input.rowing ? (0.12 + entity.rowers * 0.06) : 0;
  const sailAlignment = entity.sailOpen ? Math.max(0, fwd.x * windDir.x + fwd.y * windDir.y) : 0;
  const sailPush = entity.sailOpen ? sailAlignment * (0.1 + entity.size * 0.0015) : 0;
  const drag = input.brake ? 0.052 : 0.018;
  const accel = (rowPower + sailPush) / Math.max(1, entity.mass / 16);
  const pace = dt * 12;

  entity.speed += accel * pace;
  entity.speed -= drag * entity.speed * pace;
  entity.speed = clamp(entity.speed, 0, entity.baseSpeed + 1.6);

  const steer = 0.011 + entity.rudder * 0.005 + entity.rowers * 0.0015;
  const speedFactor = 0.3 + Math.min(1.1, entity.speed / 2.3);
  if (input.turnLeft) entity.heading -= steer * speedFactor * pace;
  if (input.turnRight) entity.heading += steer * speedFactor * pace;

  const rowerMitigation = Math.min(0.82, entity.rowers * 0.14);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  entity.x += fwd.x * entity.speed * pace + wx * dt * 5.2;
  entity.y += fwd.y * entity.speed * pace + wy * dt * 5.2;
  entity.x = clamp(entity.x, 24, state.world.width - 24);
  entity.y = clamp(entity.y, 24, state.world.height - 24);
}

function resolveIslandCollisions(entity, dt, playerCollision = false) {
  for (const island of state.islands) {
    const centerDist = Math.hypot(entity.x - island.x, entity.y - island.y);
    if (centerDist > island.r + entity.size + 20) continue;

    for (const patch of island.patches) {
      const dx = entity.x - patch.x;
      const dy = entity.y - patch.y;
      const d = Math.hypot(dx, dy) || 1;
      const minDist = patch.size * 0.82 + entity.size * 0.62;
      if (d < minDist) {
        const nx = dx / d;
        const ny = dy / d;
        const push = minDist - d + 0.1;
        entity.x += nx * push;
        entity.y += ny * push;
        entity.speed *= 0.25;

        if (playerCollision) {
          const impact = 3.5 + entity.mass * 0.03;
          player.hp -= impact * dt * 0.5;
        }
      }
    }
  }
}

function spawnEnemy() {
  const cfg = getLevelConfig(state.stageIndex);
  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12 + state.difficultyFromSize * 0.09;

  const edge = Math.floor(Math.random() * 4);
  const margin = 130;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(20, Math.min(state.world.width - 20, x));
  y = Math.max(20, Math.min(state.world.height - 20, y));

  const t = Math.random();
  let kind = 'pirate';
  if (t > 0.66) kind = 'raider';
  if (t > 0.9) kind = 'rammer';

  const base = (12 + state.level * 1.2) * difficultyMult;
  const size = (kind === 'raider' ? 18 : kind === 'rammer' ? 13 : 15) + state.difficultyFromSize * 0.45;
  const hp = base * (kind === 'raider' ? 2.1 : kind === 'rammer' ? 1.4 : 1);
  const baseSpeed = (kind === 'rammer' ? 2.3 : kind === 'raider' ? 1.45 : 1.75) * (1 + cfg.spawnRate * 0.04);
  const cannons = Math.max(0, Math.floor(state.difficultyTier / 2) + (kind === 'raider' ? 1 : 0) + (Math.random() < 0.25 ? 1 : 0));
  const gunners = 1 + Math.floor(state.difficultyTier / 2) + (kind === 'raider' ? 2 : 1);
  const rowers = 1 + Math.floor(state.stageIndex / 2) + (kind === 'rammer' ? 2 : 0);
  const cannonPivot = clamp((Math.floor(state.difficultyTier / 3) * 5) + (Math.random() < 0.22 ? 5 : 0), 0, 20);

  state.enemies.push({
    x,
    y,
    hp,
    maxHp: hp,
    size,
    kind,
    heading: Math.random() * Math.PI * 2,
    speed: 0,
    baseSpeed,
    rowers,
    sailOpen: true,
    gunners,
    cannons,
    cannonPivot,
    rudder: kind === 'rammer' ? 2 : 1,
    mass: 20 + size * 0.9,
    gunReload: Math.max(0.72, 1.3 - state.difficultyTier * 0.035),
    cannonReload: Math.max(1.05, 2.1 - state.difficultyTier * 0.05),
    gunTimer: Math.random() * 0.8,
    cannonTimer: Math.random() * 1.2,
    gunRange: 102 + size * 3.0 + state.difficultyTier * 7,
    cannonRange: Math.max(158 + size * 4.5 + cannons * 14 + state.difficultyTier * 9, 102 + size * 3.0 + state.difficultyTier * 7 + 55),
    bulletDamage: 5 + state.difficultyTier * 1.5 + cannons * 1.2,
    hullLength: 0.9 + Math.random() * 0.3,
    hullBeam: 0.86 + Math.random() * 0.3,
    bowSharpness: 0.9 + Math.random() * 0.45,
    sternTaper: 0.78 + Math.random() * 0.42,
    hullColor: kind === 'raider' ? '#5c3f35' : kind === 'rammer' ? '#6a3d2f' : '#394f60',
    sailColor: kind === 'raider' ? '#d7d2c1' : '#d4e6f5'
  });
}

function spawnBoss() {
  const edge = Math.floor(Math.random() * 4);
  const margin = 170;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(30, Math.min(state.world.width - 30, x));
  y = Math.max(30, Math.min(state.world.height - 30, y));

  const hp = 260 + state.level * 18 + state.difficultyTier * 45;
  const size = 30 + state.difficultyTier * 1.2 + state.difficultyFromSize * 0.6;

  state.enemies.push({
    x,
    y,
    hp,
    maxHp: hp,
    size,
    kind: 'boss',
    heading: Math.random() * Math.PI * 2,
    speed: 0,
    baseSpeed: 1.2 + state.difficultyTier * 0.06,
    rowers: 3 + Math.floor(state.difficultyTier / 2),
    sailOpen: true,
    gunners: 4 + state.difficultyTier,
    cannons: 4 + Math.floor(state.difficultyTier / 2),
    cannonPivot: clamp(5 + Math.floor(state.difficultyTier / 2) * 5, 5, 25),
    rudder: 2,
    mass: 46 + size,
    gunReload: Math.max(0.78, 1.25 - state.difficultyTier * 0.03),
    cannonReload: Math.max(0.82, 1.45 - state.difficultyTier * 0.04),
    gunTimer: 0.4,
    cannonTimer: 0.7,
    gunRange: 150 + size * 3.3,
    cannonRange: Math.max(245 + size * 4.8 + state.difficultyTier * 14, 150 + size * 3.3 + 80),
    bulletDamage: 10 + state.difficultyTier * 2.4,
    hullLength: 1 + Math.random() * 0.25,
    hullBeam: 1 + Math.random() * 0.2,
    bowSharpness: 1 + Math.random() * 0.3,
    sternTaper: 0.82 + Math.random() * 0.28,
    hullColor: '#7b2e3d',
    sailColor: '#f1d1d8'
  });
}

function getForwardVector() {
  return { x: Math.cos(player.heading), y: Math.sin(player.heading) };
}

function getRightVector() {
  const f = getForwardVector();
  return { x: -f.y, y: f.x };
}

function broadsideFire(sideSign, target, distanceToTarget, allowGunFire, allowCannonFire) {
  const right = getRightVector();
  const forward = getForwardVector();
  const guns = Math.max(2, player.gunners + player.cannons * 2);
  const isCannon = (portIndex) => portIndex < player.cannons * 2;
  const ranges = getPlayerRanges();
  const allowGun = distanceToTarget <= ranges.gun && allowGunFire;
  const allowCannon = distanceToTarget <= ranges.cannon && allowCannonFire;

  if (!allowGun && !allowCannon) return { firedGun: false, firedCannon: false };

  const baseDir = player.heading + sideSign * Math.PI / 2;
  const targetAngle = target ? Math.atan2(target.y - player.y, target.x - player.x) : baseDir;
  const clamped = clamp(angleDiff(targetAngle, baseDir), -player.cannonPivot * (Math.PI / 180), player.cannonPivot * (Math.PI / 180));
  let firedGun = false;
  let firedCannon = false;

  for (let i = 0; i < guns; i++) {
    const cannonPort = isCannon(i);
    if (cannonPort && !allowCannon) continue;
    if (!cannonPort && !allowGun) continue;

    const t = guns === 1 ? 0.5 : i / (guns - 1);
    const along = (t - 0.5) * player.size * 1.7;
    const sideOffset = sideSign * (player.size * 0.72);
    const spawnX = player.x + forward.x * along + right.x * sideOffset;
    const spawnY = player.y + forward.y * along + right.y * sideOffset;

    const spread = (Math.random() - 0.5) * 0.16;
    const cannonAdjust = cannonPort ? clamped : 0;
    const dir = cannonPort ? (baseDir + cannonAdjust + spread) : (targetAngle + spread);
    const speed = player.bulletSpeed + (cannonPort ? 0.45 : 0.2);
    const dmg = player.bulletDamage + (cannonPort ? 4 : 0);

    state.bullets.push({
      x: spawnX,
      y: spawnY,
      vx: Math.cos(dir) * speed,
      vy: Math.sin(dir) * speed,
      dmg,
      heavy: cannonPort,
      owner: 'player'
    });
    if (cannonPort) firedCannon = true;
    else firedGun = true;
  }

  return { firedGun, firedCannon };
}

function enemyVolley(enemy, sideSign, distanceToTarget, allowGunFire, allowCannonFire) {
  const fwd = { x: Math.cos(enemy.heading), y: Math.sin(enemy.heading) };
  const right = { x: -fwd.y, y: fwd.x };
  const targetAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
  const allowGun = distanceToTarget <= enemy.gunRange && allowGunFire;
  const allowCannon = distanceToTarget <= enemy.cannonRange && allowCannonFire;
  let firedGun = false;
  let firedCannon = false;

  if (allowGun) {
    const gunCount = Math.max(1, enemy.gunners);
    for (let i = 0; i < gunCount; i++) {
      const t = gunCount === 1 ? 0.5 : i / (gunCount - 1);
      const along = (t - 0.5) * enemy.size * 1.45;
      const sideOffset = sideSign * enemy.size * 0.58;
      const spawnX = enemy.x + fwd.x * along + right.x * sideOffset;
      const spawnY = enemy.y + fwd.y * along + right.y * sideOffset;
      const dir = targetAngle + (Math.random() - 0.5) * 0.2;
      state.bullets.push({
        x: spawnX,
        y: spawnY,
        vx: Math.cos(dir) * 4.6,
        vy: Math.sin(dir) * 4.6,
        dmg: enemy.bulletDamage * 0.48,
        heavy: false,
        owner: 'enemy'
      });
      firedGun = true;
    }
  }

  if (allowCannon) {
    const cannonCount = Math.max(0, enemy.cannons);
    const baseDir = enemy.heading + sideSign * Math.PI / 2;
    const clamped = clamp(angleDiff(targetAngle, baseDir), -enemy.cannonPivot * (Math.PI / 180), enemy.cannonPivot * (Math.PI / 180));
    for (let i = 0; i < cannonCount; i++) {
      const t = cannonCount === 1 ? 0.5 : i / (cannonCount - 1);
      const along = (t - 0.5) * enemy.size * 1.2;
      const sideOffset = sideSign * enemy.size * 0.74;
      const spawnX = enemy.x + fwd.x * along + right.x * sideOffset;
      const spawnY = enemy.y + fwd.y * along + right.y * sideOffset;
      const dir = baseDir + clamped + (Math.random() - 0.5) * 0.1;
      state.bullets.push({
        x: spawnX,
        y: spawnY,
        vx: Math.cos(dir) * 4.1,
        vy: Math.sin(dir) * 4.1,
        dmg: enemy.bulletDamage,
        heavy: true,
        owner: 'enemy'
      });
      firedCannon = true;
    }
  }

  return { firedGun, firedCannon };
}

function shootAtNearest() {
  if (!state.enemies.length) return { firedGun: false, firedCannon: false };
  let target = null;
  let best = Infinity;
  for (const enemy of state.enemies) {
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 < best) {
      best = d2;
      target = enemy;
    }
  }
  if (!target) return { firedGun: false, firedCannon: false };

  const forward = getForwardVector();
  const dx = target.x - player.x;
  const dy = target.y - player.y;
  const dist = Math.hypot(dx, dy);
  const ranges = getPlayerRanges();
  if (dist > Math.max(ranges.gun, ranges.cannon)) return { firedGun: false, firedCannon: false };
  const cross = forward.x * dy - forward.y * dx;
  const sideSign = cross >= 0 ? 1 : -1;
  const canGun = player.gunTimer >= player.gunReload;
  const canCannon = player.cannonTimer >= player.cannonReload;
  if (!canGun && !canCannon) return { firedGun: false, firedCannon: false };
  return broadsideFire(sideSign, target, dist, canGun, canCannon);
}

function offerUpgrades() {
  const shuffled = [...upgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Choose an Upgrade',
    options: shuffled,
    major: false
  };
}

function offerMajorUpgrades() {
  const shuffled = [...majorUpgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Boss Defeated — Choose a Major Upgrade',
    options: shuffled,
    major: true
  };
}

function addGold(amount) {
  state.gold += amount;
  state.xp += amount;
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level += 1;
    state.xpToNext = Math.floor(state.xpToNext * 1.3 + 5);
    player.size += 0.6;
    player.maxHp += 2;
    player.hp = Math.min(player.maxHp, player.hp + 4);
    offerUpgrades();
  }
}

function drawHullBody(size, hullColor, trimColor, profile, ramEnabled = false) {
  const len = size * clamp(profile.hullLength ?? 1, 0.78, 1.55);
  const beam = size * clamp(profile.hullBeam ?? 1, 0.7, 1.45);
  const bow = clamp(profile.bowSharpness ?? 1, 0.72, 1.7);
  const stern = clamp(profile.sternTaper ?? 1, 0.6, 1.5);

  const bowX = len * (1.05 + bow * 0.14);
  const shoulderX = len * 0.34;
  const sternShoulderX = -len * (0.7 + stern * 0.2);
  const sternX = -len * (0.95 + stern * 0.24);

  ctx.fillStyle = hullColor;
  ctx.beginPath();
  ctx.moveTo(bowX, 0);
  ctx.lineTo(shoulderX, -beam * 0.62);
  ctx.lineTo(sternShoulderX, -beam * 0.46);
  ctx.lineTo(sternX, 0);
  ctx.lineTo(sternShoulderX, beam * 0.46);
  ctx.lineTo(shoulderX, beam * 0.62);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = trimColor;
  ctx.beginPath();
  ctx.moveTo(bowX * 0.82, 0);
  ctx.lineTo(shoulderX * 0.78, -beam * 0.44);
  ctx.lineTo(sternShoulderX * 0.72, -beam * 0.3);
  ctx.lineTo(sternX * 0.74, 0);
  ctx.lineTo(sternShoulderX * 0.72, beam * 0.3);
  ctx.lineTo(shoulderX * 0.78, beam * 0.44);
  ctx.closePath();
  ctx.fill();

  if (ramEnabled) {
    ctx.fillStyle = '#bdb7b0';
    ctx.beginPath();
    ctx.moveTo(bowX, -4);
    ctx.lineTo(bowX + 12, 0);
    ctx.lineTo(bowX, 4);
    ctx.closePath();
    ctx.fill();
  }

  return { len, beam, bowX };
}

window.addEventListener('keydown', (e) => {
  if (!state.upgradesOffered) return;
  const key = e.key;
  const idx = key === '1' ? 0 : key === '2' ? 1 : key === '3' ? 2 : -1;
  if (idx >= 0 && state.upgradesOffered.options[idx]) {
    state.upgradesOffered.options[idx].apply();
    state.upgradesOffered = null;
  }
});

function update(dt) {
  if (state.gameOver) return;
  if (state.upgradesOffered) return;

  state.time += dt;

  const cfg = getLevelConfig(state.stageIndex);
  state.stageTimer += dt;
  state.bossTimer += dt;

  if (state.stageTimer >= cfg.duration) {
    state.stageTimer = 0;
    if (ENDLESS_MODE || state.stageIndex < LEVEL_CONFIGS.length - 1) {
      state.stageIndex += 1;
    }
  }

  const hasBossAlive = state.enemies.some((e) => e.kind === 'boss');
  if (state.bossTimer >= cfg.bossEvery && !hasBossAlive) {
    state.bossTimer = 0;
    spawnBoss();
  }

  state.wind.timer += dt;
  if (state.wind.timer > cfg.windShift) {
    state.wind.timer = 0;
    const angle = Math.random() * Math.PI * 2;
    const strength = 0.2 + Math.random() * 0.35;
    state.wind.x = Math.cos(angle) * strength;
    state.wind.y = Math.sin(angle) * strength;
  }

  const forwardPressed = keys.has('w') || keys.has('arrowup');
  const brakePressed = keys.has('s') || keys.has('arrowdown');
  const turnLeft = keys.has('a') || keys.has('arrowleft');
  const turnRight = keys.has('d') || keys.has('arrowright');

  const fwd = getForwardVector();
  const windMag = Math.hypot(state.wind.x, state.wind.y) || 1;
  const windDir = { x: state.wind.x / windMag, y: state.wind.y / windMag };

  const rowPower = forwardPressed ? (0.14 + player.rowers * 0.075) : 0;
  state.rowEffort = clamp(rowPower / 0.55, 0, 1);
  const sailAlignment = player.sailOpen ? Math.max(0, fwd.x * windDir.x + fwd.y * windDir.y) : 0;
  const sailPush = player.sailOpen ? sailAlignment * (0.11 + player.size * 0.0018) : 0;
  const drag = brakePressed ? 0.06 : 0.018;
  const pace = dt * 12;

  const accel = (rowPower + sailPush) / Math.max(1, player.mass / 16);
  player.speed += accel * pace;
  player.speed -= drag * player.speed * pace;
  player.speed = Math.max(0, Math.min(player.baseSpeed + 1.9, player.speed));

  const steerAuthority = 0.012 + player.rudder * 0.006 + player.rowers * 0.002;
  const speedFactor = 0.3 + Math.min(1.2, player.speed / 2.4);
  if (turnLeft) player.heading -= steerAuthority * speedFactor * pace;
  if (turnRight) player.heading += steerAuthority * speedFactor * pace;

  const rowerMitigation = Math.min(0.85, player.rowers * 0.16);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  player.x += fwd.x * player.speed * pace + wx * dt * 6;
  player.y += fwd.y * player.speed * pace + wy * dt * 6;

  player.x = Math.max(24, Math.min(state.world.width - 24, player.x));
  player.y = Math.max(24, Math.min(state.world.height - 24, player.y));
  resolveIslandCollisions(player, dt, true);

  const zoomTarget = clamp(1 - (player.size - 16) * 0.008 + state.zoomUserOffset, 0.5, 1.6);
  state.zoom += (zoomTarget - state.zoom) * 0.09;
  state.difficultyFromSize = Math.floor(Math.max(0, (16 - state.zoom * 16) * 0.9));
  ensureIslandDefenses();
  updateCamera();

  player.gunTimer += dt;
  player.cannonTimer += dt;
  const firedPlayer = shootAtNearest();
  if (firedPlayer.firedGun) player.gunTimer = 0;
  if (firedPlayer.firedCannon) player.cannonTimer = 0;

  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12 + state.difficultyFromSize * 0.09;
  const spawnChance = (0.0069 * cfg.spawnRate + state.level * 0.00013 + state.difficultyTier * 0.0002 + state.difficultyFromSize * 0.00025) * dt * 60;
  if (Math.random() < spawnChance) spawnEnemy();

  for (const bullet of state.bullets) {
    bullet.x += bullet.vx * dt * 60;
    bullet.y += bullet.vy * dt * 60;
  }
  state.bullets = state.bullets.filter(b => b.x > -30 && b.x < state.world.width + 30 && b.y > -30 && b.y < state.world.height + 30);

  function getEnemySteerTarget(enemy) {
    if (enemy.kind === 'boss' || enemy.kind === 'rammer') {
      return { x: player.x, y: player.y };
    }

    let bestAlly = null;
    let bestD2 = Infinity;
    const followRange = 220;
    for (const ally of state.enemies) {
      if (ally === enemy || ally.kind === 'boss' || ally.kind === 'rammer') continue;
      const dx = ally.x - enemy.x;
      const dy = ally.y - enemy.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < followRange * followRange && d2 < bestD2) {
        bestD2 = d2;
        bestAlly = ally;
      }
    }

    if (!bestAlly) return { x: player.x, y: player.y };

    if (enemy.kind === 'pirate') {
      return { x: bestAlly.x, y: bestAlly.y };
    }

    if (enemy.kind === 'raider') {
      const lead = 40;
      return {
        x: bestAlly.x + Math.cos(bestAlly.heading) * lead,
        y: bestAlly.y + Math.sin(bestAlly.heading) * lead
      };
    }

    return { x: player.x, y: player.y };
  }

  for (const enemy of state.enemies) {
    const target = getEnemySteerTarget(enemy);
    const desired = Math.atan2(target.y - enemy.y, target.x - enemy.x);
    const turnDelta = angleDiff(desired, enemy.heading);
    const turnLeftEnemy = turnDelta < -0.03;
    const turnRightEnemy = turnDelta > 0.03;
    const distToTarget = Math.hypot(target.x - enemy.x, target.y - enemy.y);

    simulateVessel(enemy, dt, {
      rowing: distToTarget > enemy.size * 2.4,
      brake: false,
      turnLeft: turnLeftEnemy,
      turnRight: turnRightEnemy
    });
    resolveIslandCollisions(enemy, dt, false);

    enemy.gunTimer += dt;
    enemy.cannonTimer += dt;
    const fwdEnemy = { x: Math.cos(enemy.heading), y: Math.sin(enemy.heading) };
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.hypot(dx, dy);
    const cross = fwdEnemy.x * dy - fwdEnemy.y * dx;
    const sideSign = cross >= 0 ? 1 : -1;
    const canGun = enemy.gunTimer >= enemy.gunReload;
    const canCannon = enemy.cannonTimer >= enemy.cannonReload;
    if (canGun || canCannon) {
      const fired = enemyVolley(enemy, sideSign, dist, canGun, canCannon);
      if (fired.firedGun) enemy.gunTimer = 0;
      if (fired.firedCannon) enemy.cannonTimer = 0;
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];

    for (let j = state.bullets.length - 1; j >= 0; j--) {
      const b = state.bullets[j];
      if (b.owner === 'enemy') continue;
      const d = Math.hypot(enemy.x - b.x, enemy.y - b.y);
      if (d < enemy.size + 4) {
        enemy.hp -= b.dmg;
        state.bullets.splice(j, 1);
        if (enemy.hp <= 0) {
          state.enemies.splice(i, 1);
          if (enemy.kind === 'boss') {
            state.difficultyTier += 1;
            state.bossesDefeated += 1;
            offerMajorUpgrades();
            state.drops.push({ x: enemy.x, y: enemy.y, v: 22 + Math.random() * 6 });
          } else {
            const bonus = enemy.kind === 'raider' ? 6 : 3;
            state.drops.push({ x: enemy.x, y: enemy.y, v: bonus + Math.random() * 2.5 });
          }
          break;
        }
      }
    }
  }

  for (const island of state.islands) {
    for (let i = island.buildings.length - 1; i >= 0; i--) {
      const building = island.buildings[i];
      for (let j = state.bullets.length - 1; j >= 0; j--) {
        const b = state.bullets[j];
        if (b.owner !== 'player' || !b.heavy) continue;
        const d = Math.hypot(building.x - b.x, building.y - b.y);
        if (d < building.size * 0.65 + 4) {
          building.hp -= b.dmg * 1.05;
          state.bullets.splice(j, 1);
          if (building.hp <= 0) {
            const goldCount = Math.max(2, Math.floor(building.size / 4));
            for (let g = 0; g < goldCount; g++) {
              const ang = Math.random() * Math.PI * 2;
              const dist = Math.random() * building.size * 0.9;
              state.drops.push({
                x: building.x + Math.cos(ang) * dist,
                y: building.y + Math.sin(ang) * dist,
                v: 1 + building.size * 0.16 + Math.random() * 1.6
              });
            }
            island.buildings.splice(i, 1);
          }
          break;
        }
      }
    }

    const activeTowers = island.buildings.filter((b) => b.tower);
    for (const tower of activeTowers) {
      tower.fireTimer += dt;
      const cadence = Math.max(0.7, 1.6 - island.defenseLevel * 0.12);
      if (tower.fireTimer >= cadence) {
        tower.fireTimer = 0;
        const ang = Math.atan2(player.y - tower.y, player.x - tower.x) + (Math.random() - 0.5) * 0.16;
        state.bullets.push({
          x: tower.x,
          y: tower.y,
          vx: Math.cos(ang) * 4.2,
          vy: Math.sin(ang) * 4.2,
          dmg: 5 + island.defenseLevel * 1.5,
          heavy: true,
          owner: 'enemy'
        });
      }
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];
    const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
    if (d < enemy.size + player.size * 0.7) {
      if (player.ram && enemy.kind !== 'raider' && enemy.kind !== 'boss') {
        state.enemies.splice(i, 1);
        state.drops.push({ x: enemy.x, y: enemy.y, v: 3 + Math.random() * 2 });
      } else {
        const impact = enemy.kind === 'boss' ? 20 : enemy.kind === 'monster' ? 12 : 7;
        player.hp -= impact * dt * 4;
        if (player.ram && enemy.kind === 'boss') {
          enemy.hp -= player.ramDamage * dt * 1.15;
        }
      }
    }
  }

  for (let i = state.bullets.length - 1; i >= 0; i--) {
    const b = state.bullets[i];
    if (b.owner !== 'enemy') continue;
    const d = Math.hypot(player.x - b.x, player.y - b.y);
    if (d < player.size * 0.78 + 4) {
      player.hp -= b.dmg * (b.heavy ? 0.28 : 0.18);
      state.bullets.splice(i, 1);
    }
  }

  for (let i = state.drops.length - 1; i >= 0; i--) {
    const d = state.drops[i];
    const dx = player.x - d.x;
    const dy = player.y - d.y;
    if (Math.hypot(dx, dy) < 14) {
      addGold(d.v);
      state.drops.splice(i, 1);
    }
  }

  for (const cloud of state.clouds) {
    cloud.x += (state.wind.x * 0.35 + cloud.drift) * dt * 60;
    cloud.y += (state.wind.y * 0.2) * dt * 60;
    if (cloud.x > state.world.width + 200) cloud.x = -220;
    if (cloud.x < -240) cloud.x = state.world.width + 180;
    if (cloud.y > state.world.height + 120) cloud.y = -120;
    if (cloud.y < -120) cloud.y = state.world.height + 120;
  }

  if (player.hp <= 0) {
    player.hp = 0;
    state.gameOver = true;
  }
}

function drawShip() {
  const s = player.size;
  ctx.save();
  const pos = toScreen(player.x, player.y);
  ctx.translate(pos.x, pos.y);
  ctx.rotate(player.heading);
  ctx.scale(state.zoom, state.zoom);

  const hull = drawHullBody(s, player.hullColor, player.trimColor, player, player.ram);
  const sLen = hull.len;
  const sBeam = hull.beam;

  ctx.fillStyle = player.trimColor;
  const mast = Math.max(8, s * 1.2 * player.mastScale);
  ctx.fillRect(-2, -mast, 4, mast);

  if (player.sailOpen) {
    ctx.fillStyle = player.sailColor;
    ctx.beginPath();
    ctx.moveTo(2, -mast + 2);
    ctx.lineTo(s * 1.1, -mast * 0.65);
    ctx.lineTo(2, -mast * 0.3);
    ctx.closePath();
    ctx.fill();
  }

  const crewCount = Math.min(10, player.crew + player.cannons);
  ctx.fillStyle = '#1f2f3a';
  for (let i = 0; i < crewCount; i++) {
    const px = -sLen * 0.62 + (i % 5) * (sLen * 0.27);
    const py = -sBeam * 0.22 + Math.floor(i / 5) * (sBeam * 0.35);
    ctx.beginPath();
    ctx.arc(px, py, 2.2, 0, Math.PI * 2);
    ctx.fill();
  }

  const gunPorts = Math.max(2, player.gunners);
  for (let i = 0; i < gunPorts; i++) {
    const t = gunPorts === 1 ? 0.5 : i / (gunPorts - 1);
    const along = -sLen * 0.62 + t * sLen * 1.24;

    ctx.fillStyle = '#d5dbe2';
    ctx.fillRect(along - 1.6, -sBeam * 0.67, 3.2, 2.2);
    ctx.fillRect(along - 1.6, sBeam * 0.63, 3.2, 2.2);
  }

  const cannonPorts = Math.max(0, player.cannons);
  for (let i = 0; i < cannonPorts; i++) {
    const t = cannonPorts === 1 ? 0.5 : i / (cannonPorts - 1);
    const along = -sLen * 0.52 + t * sLen * 1.08;

    ctx.fillStyle = '#5f656c';
    ctx.fillRect(along - 5, -sBeam * 0.79, 10, 4);
    ctx.fillRect(along - 5, sBeam * 0.73, 10, 4);
  }

  ctx.restore();
}

function drawEnemyShip(enemy) {
  const s = enemy.size;
  const pos = toScreen(enemy.x, enemy.y);
  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(enemy.heading);
  ctx.scale(state.zoom, state.zoom);

  const hull = drawHullBody(s, enemy.hullColor, '#b8997a', enemy, false);
  const sLen = hull.len;
  const sBeam = hull.beam;

  ctx.fillStyle = '#b8997a';
  ctx.fillRect(-1.5, -s * 1.12, 3, s * 1.12);

  if (enemy.sailOpen) {
    ctx.fillStyle = enemy.sailColor;
    ctx.beginPath();
    ctx.moveTo(2, -s * 1.12);
    ctx.lineTo(s * 0.95, -s * 0.76);
    ctx.lineTo(2, -s * 0.45);
    ctx.closePath();
    ctx.fill();
  }

  for (let i = 0; i < Math.max(1, enemy.gunners); i++) {
    const t = enemy.gunners <= 1 ? 0.5 : i / (enemy.gunners - 1);
    const along = -sLen * 0.62 + t * sLen * 1.24;
    ctx.fillStyle = '#d0d6de';
    ctx.fillRect(along - 1.5, -sBeam * 0.64, 3, 2);
    ctx.fillRect(along - 1.5, sBeam * 0.59, 3, 2);
  }

  for (let i = 0; i < enemy.cannons; i++) {
    const t = enemy.cannons <= 1 ? 0.5 : i / (enemy.cannons - 1);
    const along = -sLen * 0.52 + t * sLen * 1.08;
    ctx.fillStyle = '#596068';
    ctx.fillRect(along - 4.5, -sBeam * 0.76, 9, 3.8);
    ctx.fillRect(along - 4.5, sBeam * 0.71, 9, 3.8);
  }

  ctx.restore();
}

function drawWorld() {
  const camX = state.camera.x;
  const camY = state.camera.y;
  const z = state.zoom;
  const viewW = canvas.width / z;
  const viewH = canvas.height / z;

  const tile = 16;
  const startX = Math.floor(camX / tile) * tile;
  const startY = Math.floor(camY / tile) * tile;
  for (let worldY = startY; worldY < camY + viewH + tile; worldY += tile) {
    for (let worldX = startX; worldX < camX + viewW + tile; worldX += tile) {
      const pattern = ((Math.floor(worldX / tile) + Math.floor(worldY / tile)) % 2 === 0);
      ctx.fillStyle = pattern ? '#0a2e45' : '#0b334d';
      ctx.fillRect((worldX - camX) * z, (worldY - camY) * z, tile * z + 1, tile * z + 1);
    }
  }

  ctx.strokeStyle = 'rgba(132,188,220,0.16)';
  for (let y = 0; y < canvas.height; y += 20 * z) {
    const worldY = camY + y / z;
    ctx.beginPath();
    ctx.moveTo(0, y + Math.sin((state.time * 1.4) + worldY * 0.03) * 2 * z);
    ctx.lineTo(canvas.width, y + Math.sin((state.time * 1.4) + worldY * 0.03) * 2 * z);
    ctx.stroke();
  }

  for (const island of state.islands) {
    const sx = (island.x - camX) * z;
    const sy = (island.y - camY) * z;
    const sr = island.r * z;
    if (sx < -sr - 40 || sx > canvas.width + sr + 40 || sy < -sr - 40 || sy > canvas.height + sr + 40) continue;

    for (const patch of island.patches) {
      const px = (patch.x - camX) * z;
      const py = (patch.y - camY) * z;
      const pr = patch.size * z;
      ctx.fillStyle = patch.sides === 6 ? '#b2a46f' : '#a69663';
      polygonPath(px, py, pr, patch.sides, patch.rot);
      ctx.fill();
      ctx.fillStyle = patch.sides === 6 ? '#6e9d4b' : '#6a9349';
      polygonPath(px, py, pr * 0.62, patch.sides, patch.rot + 0.08);
      ctx.fill();
    }

    for (const building of island.buildings) {
      const bp = toScreen(building.x, building.y);
      const bw = building.size * 0.9 * z;
      const bh = building.size * z;
      ctx.fillStyle = building.tower ? '#7e8f9e' : '#ba8a63';
      ctx.fillRect(bp.x - bw * 0.5, bp.y - bh * 0.55, bw, bh);
      ctx.fillStyle = building.tower ? '#4f5d69' : '#8d5f40';
      ctx.fillRect(bp.x - bw * 0.22, bp.y - bh * 0.9, bw * 0.44, bh * 0.34);
    }
  }
}

function drawCloudOverlay() {
  const z = state.zoom;
  for (const cloud of state.clouds) {
    const sx = (cloud.x - state.camera.x) * z;
    const sy = (cloud.y - state.camera.y) * z;
    const cw = cloud.w * z;
    const ch = cloud.h * z;
    if (sx < -260 || sx > canvas.width + 260 || sy < -160 || sy > canvas.height + 160) continue;
    ctx.fillStyle = 'rgba(210,225,236,0.14)';
    ctx.fillRect(sx, sy, cw, ch);
    ctx.fillRect(sx + cw * 0.2, sy - ch * 0.35, cw * 0.6, ch * 0.45);
    ctx.fillRect(sx + cw * 0.15, sy + ch * 0.62, cw * 0.5, ch * 0.3);
  }
}

function drawHud() {
  const hpRatio = clamp(player.hp / player.maxHp, 0, 1);
  const gunLoad = clamp(player.gunTimer / player.gunReload, 0, 1);
  const cannonLoad = clamp(player.cannonTimer / player.cannonReload, 0, 1);
  const stageLabel = getLevelConfig(state.stageIndex).name;
  const modeLabel = ENDLESS_MODE ? 'Endless' : 'Campaign';
  const bossIn = Math.max(0, Math.round(getLevelConfig(state.stageIndex).bossEvery - state.bossTimer));

  const panelW = Math.min(560, canvas.width * 0.62);
  const panelX = (canvas.width - panelW) / 2;
  const panelY = 12;
  const barW = panelW - 116;
  const barH = 12;
  const labelX = panelX + 14;
  const barX = panelX + 88;

  ctx.fillStyle = 'rgba(8,20,30,0.68)';
  ctx.fillRect(panelX, panelY, panelW, 116);

  ctx.fillStyle = '#e2f3ff';
  ctx.font = '12px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(`${modeLabel} · ${stageLabel} · Lv ${state.level} · Gold ${Math.round(state.gold)} · Boss ${bossIn}s`, panelX + panelW / 2, panelY + 16);
  ctx.fillText(`Wind ${windDirectionLabel()} · Speed ${player.speed.toFixed(2)} · Row ${Math.round(state.rowEffort * 100)}% · Pivot ${player.cannonPivot}°`, panelX + panelW / 2, panelY + 32);

  ctx.textAlign = 'left';
  ctx.fillStyle = '#d8eefc';
  ctx.fillText('HULL', labelX, panelY + 53);
  ctx.fillText('GUN', labelX, panelY + 75);
  ctx.fillText('CANNON', labelX, panelY + 97);

  ctx.fillStyle = '#233746';
  ctx.fillRect(barX, panelY + 42, barW, barH);
  ctx.fillRect(barX, panelY + 64, barW, barH);
  ctx.fillRect(barX, panelY + 86, barW, barH);

  ctx.fillStyle = '#cd5454';
  ctx.fillRect(barX, panelY + 42, barW * hpRatio, barH);
  ctx.fillStyle = '#8fcfe4';
  ctx.fillRect(barX, panelY + 64, barW * gunLoad, barH);
  ctx.fillStyle = '#d8a167';
  ctx.fillRect(barX, panelY + 86, barW * cannonLoad, barH);

  ctx.fillStyle = '#ecf7ff';
  ctx.fillText(`${Math.round(player.hp)}/${player.maxHp}`, barX + barW + 8, panelY + 53);
  ctx.fillText(`${Math.round(gunLoad * 100)}%`, barX + barW + 8, panelY + 75);
  ctx.fillText(`${Math.round(cannonLoad * 100)}%`, barX + barW + 8, panelY + 97);
}

function drawRangeIndicators() {
  const pos = toScreen(player.x, player.y);
  const ranges = getPlayerRanges();

  ctx.save();
  ctx.strokeStyle = 'rgba(189,226,248,0.62)';
  ctx.lineWidth = 1.2;
  ctx.setLineDash([3, 6]);
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, ranges.gun * state.zoom, 0, Math.PI * 2);
  ctx.stroke();

  if (player.cannons > 0) {
    ctx.strokeStyle = 'rgba(232,191,142,0.64)';
    ctx.lineWidth = 2.3;
    ctx.setLineDash([12, 9]);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, ranges.cannon * state.zoom, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}

function windDirectionLabel() {
  const a = Math.atan2(state.wind.y, state.wind.x);
  const dirs = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
  const idx = Math.round(((a + Math.PI) / (Math.PI * 2)) * 8) % 8;
  return dirs[idx];
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWorld();
  drawRangeIndicators();

  drawShip();

  for (const b of state.bullets) {
    ctx.fillStyle = b.owner === 'enemy' ? (b.heavy ? '#f59b80' : '#f8baa5') : (b.heavy ? '#f1b05f' : '#ffd887');
    ctx.beginPath();
    const bp = toScreen(b.x, b.y);
    ctx.arc(bp.x, bp.y, (b.heavy ? 3.4 : 2.6) * state.zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const d of state.drops) {
    const dp = toScreen(d.x, d.y);
    const spin = Math.cos(state.time * 7 + d.x * 0.03 + d.y * 0.04);
    const rx = Math.max(1, 4 * Math.abs(spin) * state.zoom);
    const ry = 4 * state.zoom;
    ctx.fillStyle = '#ffdd55';
    ctx.fillRect(dp.x - rx, dp.y - ry, rx * 2, ry * 2);
    ctx.fillStyle = '#fff3b5';
    ctx.fillRect(dp.x - rx * 0.25, dp.y - ry * 0.9, rx * 0.5, ry * 1.8);
  }

  for (const e of state.enemies) {
    drawEnemyShip(e);

    if (e.kind === 'boss') {
      const ep = toScreen(e.x, e.y);
      ctx.fillStyle = '#f3c8d0';
      ctx.fillRect(ep.x - e.size * 0.6 * state.zoom, ep.y - (e.size + 10) * state.zoom, e.size * 1.2 * state.zoom, 6 * state.zoom);
      ctx.fillStyle = '#d74662';
      const hpRatio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      ctx.fillRect(ep.x - e.size * 0.6 * state.zoom, ep.y - (e.size + 10) * state.zoom, e.size * 1.2 * hpRatio * state.zoom, 6 * state.zoom);
    }
  }

  drawCloudOverlay();

  if (state.upgradesOffered) {
    const cardW = Math.min(560, canvas.width * 0.68);
    const cardX = (canvas.width - cardW) / 2;
    const titleX = canvas.width / 2;
    ctx.fillStyle = 'rgba(5,10,15,0.78)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f5fbff';
    ctx.font = '24px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(state.upgradesOffered.title, titleX, 120);
    ctx.font = '18px system-ui';
    state.upgradesOffered.options.forEach((u, i) => {
      const y = 200 + i * 95;
      ctx.fillStyle = state.upgradesOffered.major ? '#4a2f18' : '#163349';
      ctx.fillRect(cardX, y - 34, cardW, 62);
      ctx.fillStyle = '#e8f5ff';
      ctx.textAlign = 'left';
      ctx.fillText(`${i + 1}) ${u.name}`, cardX + 22, y - 7);
      ctx.fillStyle = '#a8c6d9';
      ctx.fillText(u.desc, cardX + 22, y + 18);
    });
    ctx.textAlign = 'left';
  }

  if (state.gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '40px system-ui';
    ctx.fillText('Ship Sunk', 390, 250);
    ctx.font = '20px system-ui';
    ctx.fillText('Refresh to sail again', 392, 290);
  }

  statsEl.textContent = '';
  windEl.textContent = '';

  drawHud();

  ctx.save();
  ctx.translate(canvas.width - 78, 76);
  ctx.strokeStyle = 'rgba(220,242,255,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI * 2);
  ctx.stroke();
  const wx = state.wind.x;
  const wy = state.wind.y;
  const len = Math.hypot(wx, wy) || 1;
  const ax = (wx / len) * 22;
  const ay = (wy / len) * 22;
  ctx.strokeStyle = '#d6ecff';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(ax, ay);
  ctx.stroke();
  ctx.fillStyle = '#d6ecff';
  ctx.fillRect(ax - 2, ay - 2, 4, 4);
  ctx.restore();
}

let last = performance.now();
initWorld();
function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
