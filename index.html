<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pirate Survivor Prototype</title>
  <style>
    html, body { margin: 0; background: #071521; color: #e8f5ff; font-family: system-ui, sans-serif; }
    .wrap { display: grid; place-items: center; min-height: 100vh; }
    canvas { border: 1px solid #2a4b63; background: radial-gradient(circle at 30% 30%, #0a2a3f, #071521 70%); }
    .hud { width: 960px; display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
    .hint { width: 960px; margin-top: 8px; color: #9fc2d9; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="stats"></div>
      <div id="wind"></div>
    </div>
    <canvas id="game" width="960" height="540"></canvas>
    <div class="hint">Steer: A/D · Row forward: W · Brake/anchor drag: S · Toggle sail: E · Auto-fire broadside · Level-up: 1/2/3</div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const statsEl = document.getElementById('stats');
const windEl = document.getElementById('wind');

const keys = new Set();
window.addEventListener('keydown', (e) => keys.add(e.key.toLowerCase()));
window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'e' && !e.repeat) {
    player.sailOpen = !player.sailOpen;
  }
});

const ENDLESS_MODE = true;
const LEVEL_CONFIGS = [
  { name: 'Coastal Skirmish', duration: 45, spawnRate: 1.0, bossEvery: 45, windShift: 16 },
  { name: 'Open Waters', duration: 55, spawnRate: 1.2, bossEvery: 50, windShift: 14 },
  { name: 'Storm Belt', duration: 65, spawnRate: 1.45, bossEvery: 55, windShift: 11 },
  { name: 'Kraken Frontier', duration: 75, spawnRate: 1.75, bossEvery: 60, windShift: 9 }
];

function getLevelConfig(stageIndex) {
  if (stageIndex < LEVEL_CONFIGS.length) {
    return LEVEL_CONFIGS[stageIndex];
  }

  const tail = LEVEL_CONFIGS[LEVEL_CONFIGS.length - 1];
  const extra = stageIndex - LEVEL_CONFIGS.length + 1;

  return {
    name: `Endless ${extra}`,
    duration: Math.max(45, tail.duration - extra * 2),
    spawnRate: tail.spawnRate + extra * 0.22,
    bossEvery: Math.max(38, tail.bossEvery - extra),
    windShift: Math.max(6, tail.windShift - Math.floor(extra * 0.4))
  };
}

const state = {
  time: 0,
  gold: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  stageIndex: 0,
  stageTimer: 0,
  difficultyTier: 0,
  bossTimer: 0,
  bossesDefeated: 0,
  enemies: [],
  bullets: [],
  drops: [],
  particles: [],
  gameOver: false,
  upgradesOffered: null,
  wind: { x: 0.35, y: -0.12, timer: 0 },
  world: { width: 3600, height: 2600 },
  camera: { x: 0, y: 0 },
  islands: [],
  clouds: []
};

const player = {
  x: 1800,
  y: 1300,
  hp: 100,
  maxHp: 100,
  size: 16,
  heading: -Math.PI / 2,
  speed: 0,
  baseSpeed: 2.6,
  fireRate: 0.42,
  fireTimer: 0,
  bulletDamage: 9,
  bulletSpeed: 6,
  rowers: 0,
  gunners: 2,
  cannons: 0,
  crew: 2,
  rudder: 0,
  sailOpen: true,
  ram: false,
  ramDamage: 46,
  mass: 28,
  slots: [],
  hullColor: '#5f4630',
  sailColor: '#f0f7ff',
  mastScale: 1,
  trimColor: '#d9b78d'
};

const upgradePool = [
  {
    name: 'Crew Musketeers',
    desc: '+1 crew, faster fire',
    apply() {
      player.crew += 1;
      player.gunners += 1;
      player.fireRate = Math.max(0.16, player.fireRate - 0.04);
      addAbility('Musketeers');
    }
  },
  {
    name: 'Cannons',
    desc: '+1 cannon, +damage',
    apply() {
      player.cannons += 1;
      player.bulletDamage += 3;
      addAbility('Cannons');
    }
  },
  {
    name: 'Rowers',
    desc: '+1 rower, wind mitigation',
    apply() {
      player.rowers += 1;
      player.baseSpeed += 0.16;
      addAbility('Rowers');
    }
  },
  {
    name: 'Reinforced Hull',
    desc: '+15 max HP and heal 10',
    apply() {
      player.maxHp += 15;
      player.hp = Math.min(player.maxHp, player.hp + 10);
      addAbility('Hull');
    }
  },
  {
    name: 'Ram Bow',
    desc: 'Ramming enabled, +size',
    apply() {
      player.ram = true;
      player.size += 2;
      addAbility('Ram');
    }
  },
  {
    name: 'Sail Mastery',
    desc: '+speed, bigger ship',
    apply() {
      player.baseSpeed += 0.25;
      player.size += 1;
      player.mass += 2;
      addAbility('Sails');
    }
  },
  {
    name: 'Rudder Upgrade',
    desc: 'Turn faster under momentum',
    apply() {
      player.rudder += 1;
      addAbility('Rudder');
    }
  }
];

const majorUpgradePool = [
  {
    name: 'Dreadnought Hull',
    desc: 'Massive hull growth, +40 max HP',
    apply() {
      player.size += 5;
      player.maxHp += 40;
      player.hp = Math.min(player.maxHp, player.hp + 28);
      player.mass += 10;
      player.hullColor = '#3f2f24';
      player.trimColor = '#c7a476';
      addAbility('Dreadnought');
    }
  },
  {
    name: 'Crimson Sails',
    desc: 'Faster ship, faster volleys',
    apply() {
      player.baseSpeed += 0.45;
      player.fireRate = Math.max(0.12, player.fireRate - 0.06);
      player.sailColor = '#d34d4d';
      player.mastScale += 0.2;
      addAbility('CrimsonSails');
    }
  },
  {
    name: 'Grand Broadside',
    desc: '+2 cannons, +10 damage',
    apply() {
      player.cannons += 2;
      player.bulletDamage += 10;
      player.size += 1;
      player.mass += 3;
      addAbility('Broadside');
    }
  },
  {
    name: 'Iron Ram Prow',
    desc: 'Deadlier collisions, ram visual',
    apply() {
      player.ram = true;
      player.ramDamage += 38;
      player.size += 2;
      player.mass += 4;
      player.hullColor = '#4a3a2e';
      addAbility('IronRam');
    }
  }
];

function addAbility(label) {
  if (player.slots.length < 4 && !player.slots.includes(label)) {
    player.slots.push(label);
  }
}

function initWorld() {
  const islandCount = 26;
  for (let i = 0; i < islandCount; i++) {
    const x = 200 + Math.random() * (state.world.width - 400);
    const y = 200 + Math.random() * (state.world.height - 400);
    const r = 34 + Math.random() * 52;
    state.islands.push({ x, y, r });
  }

  for (let i = 0; i < 11; i++) {
    state.clouds.push({
      x: Math.random() * state.world.width,
      y: Math.random() * state.world.height,
      w: 130 + Math.random() * 180,
      h: 45 + Math.random() * 60,
      drift: 0.2 + Math.random() * 0.35
    });
  }
}

function spawnEnemy() {
  const cfg = getLevelConfig(state.stageIndex);
  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12;

  const edge = Math.floor(Math.random() * 4);
  const margin = 130;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(20, Math.min(state.world.width - 20, x));
  y = Math.max(20, Math.min(state.world.height - 20, y));

  const t = Math.random();
  let kind = 'pirate';
  if (t > 0.72) kind = 'monster';
  if (t > 0.9) kind = 'rammer';

  const base = (12 + state.level * 1.2) * difficultyMult;
  const hp = kind === 'monster' ? base * 2.4 : kind === 'rammer' ? base * 1.4 : base;
  const speed = (kind === 'rammer' ? 2.25 : kind === 'monster' ? 1.25 : 1.55) * (1 + cfg.spawnRate * 0.05);
  const size = kind === 'monster' ? 19 : kind === 'rammer' ? 12 : 14;

  state.enemies.push({ x, y, hp, speed, size, kind });
}

function spawnBoss() {
  const edge = Math.floor(Math.random() * 4);
  const margin = 170;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(30, Math.min(state.world.width - 30, x));
  y = Math.max(30, Math.min(state.world.height - 30, y));

  const hp = 260 + state.level * 18 + state.difficultyTier * 45;
  const speed = 1.15 + state.difficultyTier * 0.05;
  const size = 30 + state.difficultyTier * 1.2;

  state.enemies.push({ x, y, hp, speed, size, kind: 'boss' });
}

function getForwardVector() {
  return { x: Math.cos(player.heading), y: Math.sin(player.heading) };
}

function getRightVector() {
  const f = getForwardVector();
  return { x: -f.y, y: f.x };
}

function broadsideFire(sideSign) {
  const right = getRightVector();
  const forward = getForwardVector();
  const guns = Math.max(2, player.gunners + player.cannons * 2);
  const isCannon = (portIndex) => portIndex < player.cannons * 2;

  for (let i = 0; i < guns; i++) {
    const t = guns === 1 ? 0.5 : i / (guns - 1);
    const along = (t - 0.5) * player.size * 1.7;
    const sideOffset = sideSign * (player.size * 0.72);
    const spawnX = player.x + forward.x * along + right.x * sideOffset;
    const spawnY = player.y + forward.y * along + right.y * sideOffset;

    const spread = (Math.random() - 0.5) * 0.16;
    const dir = sideSign * (Math.PI / 2 + spread) + player.heading;
    const speed = player.bulletSpeed + (isCannon(i) ? 0.45 : 0.2);
    const dmg = player.bulletDamage + (isCannon(i) ? 4 : 0);

    state.bullets.push({
      x: spawnX,
      y: spawnY,
      vx: Math.cos(dir) * speed,
      vy: Math.sin(dir) * speed,
      dmg,
      heavy: isCannon(i)
    });
  }
}

function shootAtNearest() {
  if (!state.enemies.length) return;
  let target = null;
  let best = Infinity;
  for (const enemy of state.enemies) {
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 < best) {
      best = d2;
      target = enemy;
    }
  }
  if (!target) return;

  const forward = getForwardVector();
  const dx = target.x - player.x;
  const dy = target.y - player.y;
  const cross = forward.x * dy - forward.y * dx;
  const sideSign = cross >= 0 ? 1 : -1;
  broadsideFire(sideSign);
}

function offerUpgrades() {
  const shuffled = [...upgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Choose an Upgrade',
    options: shuffled,
    major: false
  };
}

function offerMajorUpgrades() {
  const shuffled = [...majorUpgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Boss Defeated — Choose a Major Upgrade',
    options: shuffled,
    major: true
  };
}

function gainXp(amount) {
  state.xp += amount;
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level += 1;
    state.xpToNext = Math.floor(state.xpToNext * 1.3 + 5);
    player.size += 0.6;
    player.maxHp += 2;
    player.hp = Math.min(player.maxHp, player.hp + 4);
    offerUpgrades();
  }
}

window.addEventListener('keydown', (e) => {
  if (!state.upgradesOffered) return;
  const key = e.key;
  const idx = key === '1' ? 0 : key === '2' ? 1 : key === '3' ? 2 : -1;
  if (idx >= 0 && state.upgradesOffered.options[idx]) {
    state.upgradesOffered.options[idx].apply();
    state.upgradesOffered = null;
  }
});

function update(dt) {
  if (state.gameOver) return;
  if (state.upgradesOffered) return;

  state.time += dt;

  const cfg = getLevelConfig(state.stageIndex);
  state.stageTimer += dt;
  state.bossTimer += dt;

  if (state.stageTimer >= cfg.duration) {
    state.stageTimer = 0;
    if (ENDLESS_MODE || state.stageIndex < LEVEL_CONFIGS.length - 1) {
      state.stageIndex += 1;
    }
  }

  const hasBossAlive = state.enemies.some((e) => e.kind === 'boss');
  if (state.bossTimer >= cfg.bossEvery && !hasBossAlive) {
    state.bossTimer = 0;
    spawnBoss();
  }

  state.wind.timer += dt;
  if (state.wind.timer > cfg.windShift) {
    state.wind.timer = 0;
    const angle = Math.random() * Math.PI * 2;
    const strength = 0.2 + Math.random() * 0.35;
    state.wind.x = Math.cos(angle) * strength;
    state.wind.y = Math.sin(angle) * strength;
  }

  const forwardPressed = keys.has('w') || keys.has('arrowup');
  const brakePressed = keys.has('s') || keys.has('arrowdown');
  const turnLeft = keys.has('a') || keys.has('arrowleft');
  const turnRight = keys.has('d') || keys.has('arrowright');

  const fwd = getForwardVector();
  const windMag = Math.hypot(state.wind.x, state.wind.y) || 1;
  const windDir = { x: state.wind.x / windMag, y: state.wind.y / windMag };

  const rowPower = forwardPressed ? (0.14 + player.rowers * 0.075) : 0;
  const sailAlignment = player.sailOpen ? Math.max(0, fwd.x * windDir.x + fwd.y * windDir.y) : 0;
  const sailPush = player.sailOpen ? sailAlignment * (0.11 + player.size * 0.0018) : 0;
  const drag = brakePressed ? 0.06 : 0.018;

  const accel = (rowPower + sailPush) / Math.max(1, player.mass / 16);
  player.speed += accel * dt * 60;
  player.speed -= drag * player.speed * dt * 60;
  player.speed = Math.max(0, Math.min(player.baseSpeed + 1.9, player.speed));

  const steerAuthority = 0.012 + player.rudder * 0.006 + player.rowers * 0.002;
  const speedFactor = 0.3 + Math.min(1.2, player.speed / 2.4);
  if (turnLeft) player.heading -= steerAuthority * speedFactor * dt * 60;
  if (turnRight) player.heading += steerAuthority * speedFactor * dt * 60;

  const rowerMitigation = Math.min(0.85, player.rowers * 0.16);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  player.x += fwd.x * player.speed * dt * 60 + wx * dt * 30;
  player.y += fwd.y * player.speed * dt * 60 + wy * dt * 30;

  player.x = Math.max(24, Math.min(state.world.width - 24, player.x));
  player.y = Math.max(24, Math.min(state.world.height - 24, player.y));

  state.camera.x = Math.max(0, Math.min(state.world.width - canvas.width, player.x - canvas.width / 2));
  state.camera.y = Math.max(0, Math.min(state.world.height - canvas.height, player.y - canvas.height / 2));

  player.fireTimer += dt;
  if (player.fireTimer >= player.fireRate) {
    player.fireTimer = 0;
    shootAtNearest();
  }

  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12;
  const spawnChance = (0.0105 * cfg.spawnRate + state.level * 0.00022 + state.difficultyTier * 0.00035) * dt * 60;
  if (Math.random() < spawnChance) spawnEnemy();

  for (const bullet of state.bullets) {
    bullet.x += bullet.vx * dt * 60;
    bullet.y += bullet.vy * dt * 60;
  }
  state.bullets = state.bullets.filter(b => b.x > -30 && b.x < state.world.width + 30 && b.y > -30 && b.y < state.world.height + 30);

  for (const enemy of state.enemies) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const len = Math.hypot(dx, dy) || 1;
    enemy.x += (dx / len) * enemy.speed * dt * 60;
    enemy.y += (dy / len) * enemy.speed * dt * 60;
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];

    for (let j = state.bullets.length - 1; j >= 0; j--) {
      const b = state.bullets[j];
      const d = Math.hypot(enemy.x - b.x, enemy.y - b.y);
      if (d < enemy.size + 4) {
        enemy.hp -= b.dmg;
        state.bullets.splice(j, 1);
        if (enemy.hp <= 0) {
          state.enemies.splice(i, 1);
          if (enemy.kind === 'boss') {
            state.gold += 30;
            gainXp(20);
            state.difficultyTier += 1;
            state.bossesDefeated += 1;
            offerMajorUpgrades();
          } else {
            state.gold += 2;
            gainXp(3 + (enemy.kind === 'monster' ? 4 : 0));
          }
          state.drops.push({ x: enemy.x, y: enemy.y, v: 2 + Math.random() * 3 });
          break;
        }
      }
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];
    const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
    if (d < enemy.size + player.size * 0.7) {
      if (player.ram && enemy.kind !== 'monster' && enemy.kind !== 'boss') {
        state.enemies.splice(i, 1);
        state.gold += 1;
        gainXp(2);
      } else {
        const impact = enemy.kind === 'boss' ? 20 : enemy.kind === 'monster' ? 12 : 7;
        player.hp -= impact * dt * 4;
        if (player.ram && enemy.kind === 'boss') {
          enemy.hp -= player.ramDamage * dt * 1.15;
        }
      }
    }
  }

  for (let i = state.drops.length - 1; i >= 0; i--) {
    const d = state.drops[i];
    const dx = player.x - d.x;
    const dy = player.y - d.y;
    if (Math.hypot(dx, dy) < 14) {
      state.gold += d.v;
      state.drops.splice(i, 1);
    }
  }

  for (const cloud of state.clouds) {
    cloud.x += (state.wind.x * 0.35 + cloud.drift) * dt * 60;
    cloud.y += (state.wind.y * 0.2) * dt * 60;
    if (cloud.x > state.world.width + 200) cloud.x = -220;
    if (cloud.x < -240) cloud.x = state.world.width + 180;
    if (cloud.y > state.world.height + 120) cloud.y = -120;
    if (cloud.y < -120) cloud.y = state.world.height + 120;
  }

  if (player.hp <= 0) {
    player.hp = 0;
    state.gameOver = true;
  }
}

function drawShip() {
  const s = player.size;
  ctx.save();
  ctx.translate(player.x - state.camera.x, player.y - state.camera.y);
  ctx.rotate(player.heading);

  ctx.fillStyle = player.hullColor;
  ctx.fillRect(-s, -s * 0.64, s * 2, s * 1.28);

  if (player.ram) {
    ctx.fillStyle = '#bdb7b0';
    ctx.beginPath();
    ctx.moveTo(s, -5);
    ctx.lineTo(s + 10, 0);
    ctx.lineTo(s, 5);
    ctx.closePath();
    ctx.fill();
  }

  ctx.fillStyle = player.trimColor;
  const mast = Math.max(8, s * 1.3 * player.mastScale);
  ctx.fillRect(-2, -mast, 4, mast);

  if (player.sailOpen) {
    ctx.fillStyle = player.sailColor;
    ctx.beginPath();
    ctx.moveTo(2, -mast + 2);
    ctx.lineTo(s * 1.1, -mast * 0.65);
    ctx.lineTo(2, -mast * 0.3);
    ctx.closePath();
    ctx.fill();
  }

  const crewCount = Math.min(10, player.crew + player.cannons);
  ctx.fillStyle = '#1f2f3a';
  for (let i = 0; i < crewCount; i++) {
    const px = -s * 0.8 + (i % 5) * (s * 0.4);
    const py = -s * 0.3 + Math.floor(i / 5) * (s * 0.5);
    ctx.beginPath();
    ctx.arc(px, py, 2.2, 0, Math.PI * 2);
    ctx.fill();
  }

  const gunPorts = Math.max(2, player.gunners);
  for (let i = 0; i < gunPorts; i++) {
    const t = gunPorts === 1 ? 0.5 : i / (gunPorts - 1);
    const along = -s * 0.75 + t * s * 1.5;

    ctx.fillStyle = '#b9bec4';
    ctx.fillRect(along - 2, -s * 0.74, 4, 3);
    ctx.fillRect(along - 2, s * 0.71, 4, 3);
  }

  const cannonPorts = Math.max(0, player.cannons);
  for (let i = 0; i < cannonPorts; i++) {
    const t = cannonPorts === 1 ? 0.5 : i / (cannonPorts - 1);
    const along = -s * 0.65 + t * s * 1.3;

    ctx.fillStyle = '#6f747a';
    ctx.fillRect(along - 3, -s * 0.84, 6, 5);
    ctx.fillRect(along - 3, s * 0.79, 6, 5);
  }

  ctx.restore();
}

function drawWorld() {
  const camX = state.camera.x;
  const camY = state.camera.y;

  const tile = 16;
  for (let y = 0; y < canvas.height + tile; y += tile) {
    for (let x = 0; x < canvas.width + tile; x += tile) {
      const worldX = x + camX;
      const worldY = y + camY;
      const pattern = ((Math.floor(worldX / tile) + Math.floor(worldY / tile)) % 2 === 0);
      ctx.fillStyle = pattern ? '#0a2e45' : '#0b334d';
      ctx.fillRect(x, y, tile, tile);
    }
  }

  ctx.strokeStyle = 'rgba(132,188,220,0.16)';
  for (let y = 0; y < canvas.height; y += 20) {
    ctx.beginPath();
    ctx.moveTo(0, y + Math.sin((state.time * 1.4) + (y + camY) * 0.03) * 2);
    ctx.lineTo(canvas.width, y + Math.sin((state.time * 1.4) + (y + camY) * 0.03) * 2);
    ctx.stroke();
  }

  for (const island of state.islands) {
    const sx = island.x - camX;
    const sy = island.y - camY;
    if (sx < -island.r - 40 || sx > canvas.width + island.r + 40 || sy < -island.r - 40 || sy > canvas.height + island.r + 40) continue;

    ctx.fillStyle = '#b2a46f';
    ctx.beginPath();
    ctx.arc(sx, sy, island.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#6e9d4b';
    ctx.beginPath();
    ctx.arc(sx, sy, island.r * 0.68, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawCloudOverlay() {
  for (const cloud of state.clouds) {
    const sx = cloud.x - state.camera.x;
    const sy = cloud.y - state.camera.y;
    if (sx < -260 || sx > canvas.width + 260 || sy < -160 || sy > canvas.height + 160) continue;
    ctx.fillStyle = 'rgba(210,225,236,0.14)';
    ctx.fillRect(sx, sy, cloud.w, cloud.h);
    ctx.fillRect(sx + cloud.w * 0.2, sy - cloud.h * 0.35, cloud.w * 0.6, cloud.h * 0.45);
    ctx.fillRect(sx + cloud.w * 0.15, sy + cloud.h * 0.62, cloud.w * 0.5, cloud.h * 0.3);
  }
}

function windDirectionLabel() {
  const a = Math.atan2(state.wind.y, state.wind.x);
  const dirs = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
  const idx = Math.round(((a + Math.PI) / (Math.PI * 2)) * 8) % 8;
  return dirs[idx];
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWorld();

  drawShip();

  for (const b of state.bullets) {
    ctx.fillStyle = b.heavy ? '#f1b05f' : '#ffd887';
    ctx.beginPath();
    ctx.arc(b.x - state.camera.x, b.y - state.camera.y, b.heavy ? 3.4 : 2.6, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const d of state.drops) {
    ctx.fillStyle = '#ffdd55';
    ctx.beginPath();
    ctx.arc(d.x - state.camera.x, d.y - state.camera.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const e of state.enemies) {
    if (e.kind === 'boss') ctx.fillStyle = '#8d2537';
    else if (e.kind === 'monster') ctx.fillStyle = '#7e4ea6';
    else if (e.kind === 'rammer') ctx.fillStyle = '#d2573f';
    else ctx.fillStyle = '#2f4c5a';

    ctx.beginPath();
    ctx.arc(e.x - state.camera.x, e.y - state.camera.y, e.size, 0, Math.PI * 2);
    ctx.fill();

    if (e.kind === 'boss') {
      ctx.fillStyle = '#f3c8d0';
      ctx.fillRect(e.x - state.camera.x - e.size * 0.6, e.y - state.camera.y - e.size - 10, e.size * 1.2, 6);
      ctx.fillStyle = '#d74662';
      const hpRatio = Math.max(0, Math.min(1, e.hp / (260 + state.level * 18 + state.difficultyTier * 45)));
      ctx.fillRect(e.x - state.camera.x - e.size * 0.6, e.y - state.camera.y - e.size - 10, e.size * 1.2 * hpRatio, 6);
    }
  }

  drawCloudOverlay();

  if (state.upgradesOffered) {
    ctx.fillStyle = 'rgba(5,10,15,0.78)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f5fbff';
    ctx.font = '24px system-ui';
    ctx.fillText(state.upgradesOffered.title, state.upgradesOffered.major ? 265 : 360, 120);
    ctx.font = '18px system-ui';
    state.upgradesOffered.options.forEach((u, i) => {
      const y = 200 + i * 95;
      ctx.fillStyle = state.upgradesOffered.major ? '#4a2f18' : '#163349';
      ctx.fillRect(240, y - 34, 480, 62);
      ctx.fillStyle = '#e8f5ff';
      ctx.fillText(`${i + 1}) ${u.name}`, 262, y - 7);
      ctx.fillStyle = '#a8c6d9';
      ctx.fillText(u.desc, 262, y + 18);
    });
  }

  if (state.gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '40px system-ui';
    ctx.fillText('Ship Sunk', 390, 250);
    ctx.font = '20px system-ui';
    ctx.fillText('Refresh to sail again', 392, 290);
  }

  const stageLabel = getLevelConfig(state.stageIndex).name;
  const modeLabel = ENDLESS_MODE ? 'Endless' : 'Campaign';
  const sailState = player.sailOpen ? 'Open' : 'Closed';
  statsEl.textContent = `HP ${Math.round(player.hp)}/${player.maxHp} · Lv ${state.level} · Tier ${state.difficultyTier} · Bosses ${state.bossesDefeated} · Gold ${Math.round(state.gold)} · ${modeLabel} · Sail ${sailState} · Abilities [${player.slots.join(', ') || 'none'}]`;
  windEl.textContent = `${stageLabel} · Wind ${windDirectionLabel()} (${state.wind.x.toFixed(2)}, ${state.wind.y.toFixed(2)}) · Speed ${player.speed.toFixed(2)} · Next Boss ${Math.max(0, Math.round(getLevelConfig(state.stageIndex).bossEvery - state.bossTimer))}s`;

  ctx.save();
  ctx.translate(canvas.width - 78, 76);
  ctx.strokeStyle = 'rgba(220,242,255,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI * 2);
  ctx.stroke();
  const wx = state.wind.x;
  const wy = state.wind.y;
  const len = Math.hypot(wx, wy) || 1;
  const ax = (wx / len) * 22;
  const ay = (wy / len) * 22;
  ctx.strokeStyle = '#d6ecff';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(ax, ay);
  ctx.stroke();
  ctx.fillStyle = '#d6ecff';
  ctx.fillRect(ax - 2, ay - 2, 4, 4);
  ctx.restore();
}

let last = performance.now();
initWorld();
function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
