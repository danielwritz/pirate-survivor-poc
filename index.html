<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pirate Survivor Prototype</title>
  <style>
    html, body { margin: 0; background: #071521; color: #e8f5ff; font-family: system-ui, sans-serif; }
    .wrap { display: grid; place-items: center; min-height: 100vh; }
    canvas { border: 1px solid #2a4b63; background: radial-gradient(circle at 30% 30%, #0a2a3f, #071521 70%); }
    .hud { width: 960px; display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
    .hint { width: 960px; margin-top: 8px; color: #9fc2d9; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="stats"></div>
      <div id="wind"></div>
    </div>
    <canvas id="game" width="960" height="540"></canvas>
    <div class="hint">Move: WASD / Arrows · Auto-fire enabled · Level-up: press 1/2/3 to choose upgrade</div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const statsEl = document.getElementById('stats');
const windEl = document.getElementById('wind');

const keys = new Set();
window.addEventListener('keydown', (e) => keys.add(e.key.toLowerCase()));
window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

const ENDLESS_MODE = true;
const LEVEL_CONFIGS = [
  { name: 'Coastal Skirmish', duration: 45, spawnRate: 1.0, bossEvery: 45, windShift: 16 },
  { name: 'Open Waters', duration: 55, spawnRate: 1.2, bossEvery: 50, windShift: 14 },
  { name: 'Storm Belt', duration: 65, spawnRate: 1.45, bossEvery: 55, windShift: 11 },
  { name: 'Kraken Frontier', duration: 75, spawnRate: 1.75, bossEvery: 60, windShift: 9 }
];

function getLevelConfig(stageIndex) {
  if (stageIndex < LEVEL_CONFIGS.length) {
    return LEVEL_CONFIGS[stageIndex];
  }

  const tail = LEVEL_CONFIGS[LEVEL_CONFIGS.length - 1];
  const extra = stageIndex - LEVEL_CONFIGS.length + 1;

  return {
    name: `Endless ${extra}`,
    duration: Math.max(45, tail.duration - extra * 2),
    spawnRate: tail.spawnRate + extra * 0.22,
    bossEvery: Math.max(38, tail.bossEvery - extra),
    windShift: Math.max(6, tail.windShift - Math.floor(extra * 0.4))
  };
}

const state = {
  time: 0,
  gold: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  stageIndex: 0,
  stageTimer: 0,
  difficultyTier: 0,
  bossTimer: 0,
  bossesDefeated: 0,
  enemies: [],
  bullets: [],
  drops: [],
  particles: [],
  gameOver: false,
  upgradesOffered: null,
  wind: { x: 0.35, y: -0.12, timer: 0 }
};

const player = {
  x: 480,
  y: 270,
  hp: 100,
  maxHp: 100,
  size: 16,
  baseSpeed: 2.15,
  fireRate: 0.42,
  fireTimer: 0,
  bulletDamage: 9,
  bulletSpeed: 5.2,
  rowers: 0,
  cannons: 0,
  crew: 2,
  ram: false,
  ramDamage: 46,
  slots: [],
  hullColor: '#5f4630',
  sailColor: '#f0f7ff',
  mastScale: 1,
  trimColor: '#d9b78d'
};

const upgradePool = [
  {
    name: 'Crew Musketeers',
    desc: '+1 crew, faster fire',
    apply() {
      player.crew += 1;
      player.fireRate = Math.max(0.16, player.fireRate - 0.04);
      addAbility('Musketeers');
    }
  },
  {
    name: 'Cannons',
    desc: '+1 cannon, +damage',
    apply() {
      player.cannons += 1;
      player.bulletDamage += 3;
      addAbility('Cannons');
    }
  },
  {
    name: 'Rowers',
    desc: '+1 rower, wind mitigation',
    apply() {
      player.rowers += 1;
      player.baseSpeed += 0.18;
      addAbility('Rowers');
    }
  },
  {
    name: 'Reinforced Hull',
    desc: '+15 max HP and heal 10',
    apply() {
      player.maxHp += 15;
      player.hp = Math.min(player.maxHp, player.hp + 10);
      addAbility('Hull');
    }
  },
  {
    name: 'Ram Bow',
    desc: 'Ramming enabled, +size',
    apply() {
      player.ram = true;
      player.size += 2;
      addAbility('Ram');
    }
  },
  {
    name: 'Sail Mastery',
    desc: '+speed, bigger ship',
    apply() {
      player.baseSpeed += 0.25;
      player.size += 1;
      addAbility('Sails');
    }
  }
];

const majorUpgradePool = [
  {
    name: 'Dreadnought Hull',
    desc: 'Massive hull growth, +40 max HP',
    apply() {
      player.size += 5;
      player.maxHp += 40;
      player.hp = Math.min(player.maxHp, player.hp + 28);
      player.hullColor = '#3f2f24';
      player.trimColor = '#c7a476';
      addAbility('Dreadnought');
    }
  },
  {
    name: 'Crimson Sails',
    desc: 'Faster ship, faster volleys',
    apply() {
      player.baseSpeed += 0.45;
      player.fireRate = Math.max(0.12, player.fireRate - 0.06);
      player.sailColor = '#d34d4d';
      player.mastScale += 0.2;
      addAbility('CrimsonSails');
    }
  },
  {
    name: 'Grand Broadside',
    desc: '+2 cannons, +10 damage',
    apply() {
      player.cannons += 2;
      player.bulletDamage += 10;
      player.size += 1;
      addAbility('Broadside');
    }
  },
  {
    name: 'Iron Ram Prow',
    desc: 'Deadlier collisions, ram visual',
    apply() {
      player.ram = true;
      player.ramDamage += 38;
      player.size += 2;
      player.hullColor = '#4a3a2e';
      addAbility('IronRam');
    }
  }
];

function addAbility(label) {
  if (player.slots.length < 4 && !player.slots.includes(label)) {
    player.slots.push(label);
  }
}

function spawnEnemy() {
  const cfg = getLevelConfig(state.stageIndex);
  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12;

  const edge = Math.floor(Math.random() * 4);
  let x, y;
  if (edge === 0) { x = Math.random() * canvas.width; y = -20; }
  if (edge === 1) { x = canvas.width + 20; y = Math.random() * canvas.height; }
  if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 20; }
  if (edge === 3) { x = -20; y = Math.random() * canvas.height; }

  const t = Math.random();
  let kind = 'pirate';
  if (t > 0.72) kind = 'monster';
  if (t > 0.9) kind = 'rammer';

  const base = (12 + state.level * 1.2) * difficultyMult;
  const hp = kind === 'monster' ? base * 2.4 : kind === 'rammer' ? base * 1.4 : base;
  const speed = (kind === 'rammer' ? 2.25 : kind === 'monster' ? 1.25 : 1.55) * (1 + cfg.spawnRate * 0.05);
  const size = kind === 'monster' ? 19 : kind === 'rammer' ? 12 : 14;

  state.enemies.push({ x, y, hp, speed, size, kind });
}

function spawnBoss() {
  const edge = Math.floor(Math.random() * 4);
  let x, y;
  if (edge === 0) { x = Math.random() * canvas.width; y = -40; }
  if (edge === 1) { x = canvas.width + 40; y = Math.random() * canvas.height; }
  if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 40; }
  if (edge === 3) { x = -40; y = Math.random() * canvas.height; }

  const hp = 260 + state.level * 18 + state.difficultyTier * 45;
  const speed = 1.15 + state.difficultyTier * 0.05;
  const size = 30 + state.difficultyTier * 1.2;

  state.enemies.push({ x, y, hp, speed, size, kind: 'boss' });
}

function shootAtNearest() {
  if (!state.enemies.length) return;
  let target = null;
  let best = Infinity;
  for (const enemy of state.enemies) {
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 < best) {
      best = d2;
      target = enemy;
    }
  }
  if (!target) return;

  const dx = target.x - player.x;
  const dy = target.y - player.y;
  const len = Math.hypot(dx, dy) || 1;
  const vx = (dx / len) * player.bulletSpeed;
  const vy = (dy / len) * player.bulletSpeed;

  const shots = 1 + Math.floor(player.cannons / 2);
  for (let i = 0; i < shots; i++) {
    const spread = (i - (shots - 1) / 2) * 0.12;
    const rx = vx * Math.cos(spread) - vy * Math.sin(spread);
    const ry = vx * Math.sin(spread) + vy * Math.cos(spread);
    state.bullets.push({ x: player.x, y: player.y, vx: rx, vy: ry, dmg: player.bulletDamage });
  }
}

function offerUpgrades() {
  const shuffled = [...upgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Choose an Upgrade',
    options: shuffled,
    major: false
  };
}

function offerMajorUpgrades() {
  const shuffled = [...majorUpgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Boss Defeated — Choose a Major Upgrade',
    options: shuffled,
    major: true
  };
}

function gainXp(amount) {
  state.xp += amount;
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level += 1;
    state.xpToNext = Math.floor(state.xpToNext * 1.3 + 5);
    player.size += 0.6;
    player.maxHp += 2;
    player.hp = Math.min(player.maxHp, player.hp + 4);
    offerUpgrades();
  }
}

window.addEventListener('keydown', (e) => {
  if (!state.upgradesOffered) return;
  const key = e.key;
  const idx = key === '1' ? 0 : key === '2' ? 1 : key === '3' ? 2 : -1;
  if (idx >= 0 && state.upgradesOffered.options[idx]) {
    state.upgradesOffered.options[idx].apply();
    state.upgradesOffered = null;
  }
});

function update(dt) {
  if (state.gameOver) return;
  if (state.upgradesOffered) return;

  state.time += dt;

  const cfg = getLevelConfig(state.stageIndex);
  state.stageTimer += dt;
  state.bossTimer += dt;

  if (state.stageTimer >= cfg.duration) {
    state.stageTimer = 0;
    if (ENDLESS_MODE || state.stageIndex < LEVEL_CONFIGS.length - 1) {
      state.stageIndex += 1;
    }
  }

  const hasBossAlive = state.enemies.some((e) => e.kind === 'boss');
  if (state.bossTimer >= cfg.bossEvery && !hasBossAlive) {
    state.bossTimer = 0;
    spawnBoss();
  }

  state.wind.timer += dt;
  if (state.wind.timer > cfg.windShift) {
    state.wind.timer = 0;
    const angle = Math.random() * Math.PI * 2;
    const strength = 0.2 + Math.random() * 0.35;
    state.wind.x = Math.cos(angle) * strength;
    state.wind.y = Math.sin(angle) * strength;
  }

  let mx = 0, my = 0;
  if (keys.has('w') || keys.has('arrowup')) my -= 1;
  if (keys.has('s') || keys.has('arrowdown')) my += 1;
  if (keys.has('a') || keys.has('arrowleft')) mx -= 1;
  if (keys.has('d') || keys.has('arrowright')) mx += 1;

  const mLen = Math.hypot(mx, my) || 1;
  mx /= mLen; my /= mLen;

  const rowerMitigation = Math.min(0.85, player.rowers * 0.18);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  player.x += mx * player.baseSpeed * dt * 60 + wx * dt * 60;
  player.y += my * player.baseSpeed * dt * 60 + wy * dt * 60;
  player.x = Math.max(16, Math.min(canvas.width - 16, player.x));
  player.y = Math.max(16, Math.min(canvas.height - 16, player.y));

  player.fireTimer += dt;
  if (player.fireTimer >= player.fireRate) {
    player.fireTimer = 0;
    shootAtNearest();
  }

  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12;
  const spawnChance = (0.0105 * cfg.spawnRate + state.level * 0.00022 + state.difficultyTier * 0.00035) * dt * 60;
  if (Math.random() < spawnChance) spawnEnemy();

  for (const bullet of state.bullets) {
    bullet.x += bullet.vx * dt * 60;
    bullet.y += bullet.vy * dt * 60;
  }
  state.bullets = state.bullets.filter(b => b.x > -10 && b.x < canvas.width + 10 && b.y > -10 && b.y < canvas.height + 10);

  for (const enemy of state.enemies) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const len = Math.hypot(dx, dy) || 1;
    enemy.x += (dx / len) * enemy.speed * dt * 60;
    enemy.y += (dy / len) * enemy.speed * dt * 60;
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];

    for (let j = state.bullets.length - 1; j >= 0; j--) {
      const b = state.bullets[j];
      const d = Math.hypot(enemy.x - b.x, enemy.y - b.y);
      if (d < enemy.size + 4) {
        enemy.hp -= b.dmg;
        state.bullets.splice(j, 1);
        if (enemy.hp <= 0) {
          state.enemies.splice(i, 1);
          if (enemy.kind === 'boss') {
            state.gold += 30;
            gainXp(20);
            state.difficultyTier += 1;
            state.bossesDefeated += 1;
            offerMajorUpgrades();
          } else {
            state.gold += 2;
            gainXp(3 + (enemy.kind === 'monster' ? 4 : 0));
          }
          state.drops.push({ x: enemy.x, y: enemy.y, v: 2 + Math.random() * 3 });
          break;
        }
      }
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];
    const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
    if (d < enemy.size + player.size * 0.7) {
      if (player.ram && enemy.kind !== 'monster' && enemy.kind !== 'boss') {
        state.enemies.splice(i, 1);
        state.gold += 1;
        gainXp(2);
      } else {
        const impact = enemy.kind === 'boss' ? 20 : enemy.kind === 'monster' ? 12 : 7;
        player.hp -= impact * dt * 4;
        if (player.ram && enemy.kind === 'boss') {
          enemy.hp -= player.ramDamage * dt * 1.15;
        }
      }
    }
  }

  for (let i = state.drops.length - 1; i >= 0; i--) {
    const d = state.drops[i];
    const dx = player.x - d.x;
    const dy = player.y - d.y;
    const len = Math.hypot(dx, dy) || 1;
    d.x += (dx / len) * 1.8 * dt * 60;
    d.y += (dy / len) * 1.8 * dt * 60;
    if (Math.hypot(dx, dy) < 14) {
      state.gold += d.v;
      state.drops.splice(i, 1);
    }
  }

  if (player.hp <= 0) {
    player.hp = 0;
    state.gameOver = true;
  }
}

function drawShip() {
  const s = player.size;
  ctx.save();
  ctx.translate(player.x, player.y);

  ctx.fillStyle = player.hullColor;
  ctx.fillRect(-s, -s * 0.62, s * 2, s * 1.24);

  if (player.ram) {
    ctx.fillStyle = '#bdb7b0';
    ctx.beginPath();
    ctx.moveTo(s, -5);
    ctx.lineTo(s + 10, 0);
    ctx.lineTo(s, 5);
    ctx.closePath();
    ctx.fill();
  }

  ctx.fillStyle = player.trimColor;
  const mast = Math.max(8, s * 1.3 * player.mastScale);
  ctx.fillRect(-2, -mast, 4, mast);

  ctx.fillStyle = player.sailColor;
  ctx.beginPath();
  ctx.moveTo(2, -mast + 2);
  ctx.lineTo(s * 1.1, -mast * 0.65);
  ctx.lineTo(2, -mast * 0.3);
  ctx.closePath();
  ctx.fill();

  const crewCount = Math.min(10, player.crew + player.cannons);
  ctx.fillStyle = '#1f2f3a';
  for (let i = 0; i < crewCount; i++) {
    const px = -s * 0.8 + (i % 5) * (s * 0.4);
    const py = -s * 0.3 + Math.floor(i / 5) * (s * 0.5);
    ctx.beginPath();
    ctx.arc(px, py, 2.2, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = 'rgba(119,174,206,0.2)';
  for (let y = 20; y < canvas.height; y += 24) {
    ctx.beginPath();
    ctx.moveTo(0, y + Math.sin((state.time + y) * 0.03) * 2);
    ctx.lineTo(canvas.width, y + Math.sin((state.time + y) * 0.03) * 2);
    ctx.stroke();
  }

  drawShip();

  for (const b of state.bullets) {
    ctx.fillStyle = '#ffd887';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const d of state.drops) {
    ctx.fillStyle = '#ffdd55';
    ctx.beginPath();
    ctx.arc(d.x, d.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const e of state.enemies) {
    if (e.kind === 'boss') ctx.fillStyle = '#8d2537';
    else if (e.kind === 'monster') ctx.fillStyle = '#7e4ea6';
    else if (e.kind === 'rammer') ctx.fillStyle = '#d2573f';
    else ctx.fillStyle = '#2f4c5a';

    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
  }

  if (state.upgradesOffered) {
    ctx.fillStyle = 'rgba(5,10,15,0.78)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f5fbff';
    ctx.font = '24px system-ui';
    ctx.fillText(state.upgradesOffered.title, state.upgradesOffered.major ? 265 : 360, 120);
    ctx.font = '18px system-ui';
    state.upgradesOffered.options.forEach((u, i) => {
      const y = 200 + i * 95;
      ctx.fillStyle = state.upgradesOffered.major ? '#4a2f18' : '#163349';
      ctx.fillRect(240, y - 34, 480, 62);
      ctx.fillStyle = '#e8f5ff';
      ctx.fillText(`${i + 1}) ${u.name}`, 262, y - 7);
      ctx.fillStyle = '#a8c6d9';
      ctx.fillText(u.desc, 262, y + 18);
    });
  }

  if (state.gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '40px system-ui';
    ctx.fillText('Ship Sunk', 390, 250);
    ctx.font = '20px system-ui';
    ctx.fillText('Refresh to sail again', 392, 290);
  }

  const stageLabel = getLevelConfig(state.stageIndex).name;
  const modeLabel = ENDLESS_MODE ? 'Endless' : 'Campaign';
  statsEl.textContent = `HP ${Math.round(player.hp)}/${player.maxHp} · Lv ${state.level} · Tier ${state.difficultyTier} · Bosses ${state.bossesDefeated} · Gold ${Math.round(state.gold)} · ${modeLabel} · Abilities [${player.slots.join(', ') || 'none'}]`;
  windEl.textContent = `${stageLabel} · Wind ${state.wind.x.toFixed(2)}, ${state.wind.y.toFixed(2)} · Rowers ${player.rowers} · Next Boss ${Math.max(0, Math.round(getLevelConfig(state.stageIndex).bossEvery - state.bossTimer))}s`;
}

let last = performance.now();
function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
