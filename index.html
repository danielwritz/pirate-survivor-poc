<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pirate Survivor Prototype</title>
  <style>
    html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; background: #071521; color: #e8f5ff; font-family: system-ui, sans-serif; }
    .wrap { position: fixed; inset: 0; }
    canvas { display: block; width: 100vw; height: 100vh; border: 0; background: radial-gradient(circle at 30% 30%, #0a2a3f, #071521 70%); }
    .hud { position: absolute; top: 10px; left: 14px; right: 14px; z-index: 5; display: flex; justify-content: space-between; font-size: 14px; pointer-events: none; }
    .hud-right { display: flex; align-items: center; gap: 10px; pointer-events: auto; }
    .audio-btn {
      border: 1px solid #4f7896;
      background: #123149;
      color: #e8f5ff;
      font-size: 12px;
      letter-spacing: 0.3px;
      padding: 5px 10px;
      border-radius: 6px;
      cursor: pointer;
      pointer-events: auto;
    }
    .audio-btn.is-muted { background: #3a2023; border-color: #88545b; color: #ffd4d8; }
    .hint { position: absolute; left: 14px; right: 14px; bottom: 12px; z-index: 5; color: #9fc2d9; font-size: 13px; text-align: center; pointer-events: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="stats"></div>
      <div class="hud-right">
        <div id="wind"></div>
        <button id="audioToggle" class="audio-btn" type="button" aria-label="Toggle sound effects">SFX: ON</button>
      </div>
    </div>
    <canvas id="game" width="1280" height="720"></canvas>
    <div class="hint">Steer: A/D · Row forward: W · Brake/anchor drag: S · Toggle sail: Space · Mouse wheel zoom · Level-up: 1/2/3</div>
  </div>

<script src="src/systems/particleEffects.js"></script>
<script src="src/systems/audioSystem.js"></script>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const statsEl = document.getElementById('stats');
const windEl = document.getElementById('wind');
const audioToggleBtn = document.getElementById('audioToggle');

let audioSystem = null;

function resizeCanvas() {
  const w = Math.max(900, window.innerWidth);
  const h = Math.max(540, window.innerHeight);
  canvas.width = w;
  canvas.height = h;
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const keys = new Set();
window.addEventListener('keydown', (e) => keys.add(e.key.toLowerCase()));
window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

window.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();
  if ((key === ' ' || key === 'spacebar' || e.code === 'Space') && !e.repeat) {
    if (e.code === 'Space' || key === ' ') e.preventDefault();
    player.sailOpen = !player.sailOpen;
  }
});

window.addEventListener('wheel', (e) => {
  e.preventDefault();
  const step = e.deltaY > 0 ? -0.06 : 0.06;
  state.zoomUserOffset = clamp(state.zoomUserOffset + step, -0.26, 0.62);
}, { passive: false });

const ENDLESS_MODE = true;
const LEVEL_CONFIGS = [
  { name: 'Coastal Skirmish', duration: 45, spawnRate: 1.0, bossEvery: 45, windShift: 16 },
  { name: 'Open Waters', duration: 55, spawnRate: 1.2, bossEvery: 50, windShift: 14 },
  { name: 'Storm Belt', duration: 65, spawnRate: 1.45, bossEvery: 55, windShift: 11 },
  { name: 'Kraken Frontier', duration: 75, spawnRate: 1.75, bossEvery: 60, windShift: 9 }
];

function getLevelConfig(stageIndex) {
  if (stageIndex < LEVEL_CONFIGS.length) {
    return LEVEL_CONFIGS[stageIndex];
  }

  const tail = LEVEL_CONFIGS[LEVEL_CONFIGS.length - 1];
  const extra = stageIndex - LEVEL_CONFIGS.length + 1;

  return {
    name: `Endless ${extra}`,
    duration: Math.max(45, tail.duration - extra * 2),
    spawnRate: tail.spawnRate + extra * 0.22,
    bossEvery: Math.max(38, tail.bossEvery - extra),
    windShift: Math.max(6, tail.windShift - Math.floor(extra * 0.4))
  };
}

const state = {
  time: 0,
  gold: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  stageIndex: 0,
  stageTimer: 0,
  difficultyTier: 0,
  bossTimer: 0,
  bossesDefeated: 0,
  enemies: [],
  bullets: [],
  drops: [],
  particles: [],
  gameOver: false,
  upgradesOffered: null,
  wind: { x: 0.35, y: -0.12, timer: 0 },
  world: { width: 3600, height: 2600 },
  camera: { x: 0, y: 0 },
  zoom: 1,
  rowEffort: 0,
  difficultyFromSize: 0,
  defenseTier: 0,
  playerAim: null,
  zoomUserOffset: 0,
  islands: [],
  clouds: []
};

const player = {
  x: 1800,
  y: 1300,
  hp: 100,
  maxHp: 100,
  size: 16,
  heading: -Math.PI / 2,
  speed: 0,
  baseSpeed: 2.6,
  gunReload: 1.35,
  cannonReload: 2.2,
  gunTimer: 1.35,
  cannonTimer: 2.2,
  bulletDamage: 9,
  bulletSpeed: 6,
  rowers: 0,
  gunners: 2,
  repairCrew: 0,
  cannons: 0,
  cannonCapacityBonus: 0,
  cannonPivot: 0,
  crew: 2,
  rudder: 0,
  sailOpen: true,
  ram: false,
  ramDamage: 46,
  mass: 28,
  hullLength: 1,
  hullBeam: 1,
  bowSharpness: 1,
  sternTaper: 1,
  impactTimer: 0,
  repairSuppressed: 0,
  damageSeed: 1337,
  slots: [],
  hullColor: '#5f4630',
  sailColor: '#f0f7ff',
  mastScale: 1,
  maneuverPenalty: 0,
  trimColor: '#d9b78d'
};

function getPlayerRanges() {
  const gun = 128 + player.gunners * 7 + state.level * 0.8;
  const cannon = 236 + player.cannons * 20 + player.cannonPivot * 1.6 + state.level * 1.2;
  return {
    gun,
    cannon: Math.max(gun + 70, cannon)
  };
}

function getHullShape(entity) {
  const size = entity.size;
  const len = size * clamp(entity.hullLength ?? 1, 0.78, 1.55);
  const beam = size * clamp(entity.hullBeam ?? 1, 0.7, 1.45);
  const bow = clamp(entity.bowSharpness ?? 1, 0.72, 1.7);
  const stern = clamp(entity.sternTaper ?? 1, 0.6, 1.5);

  return {
    len,
    beam,
    bow,
    stern,
    bowX: len * (1.05 + bow * 0.14),
    shoulderX: len * 0.34,
    sternShoulderX: -len * (0.7 + stern * 0.2),
    sternX: -len * (0.95 + stern * 0.24)
  };
}

function getHullDims(entity) {
  const shape = getHullShape(entity);
  return { len: shape.len, beam: shape.beam };
}

function getDeckCrewCapacity(entity) {
  const shape = getHullShape(entity);
  const deckLength = shape.shoulderX - shape.sternShoulderX;
  const deckBeam = ((shape.beam * 0.62) + (shape.beam * 0.46)) * 0.5 * 2;
  const area = deckLength * deckBeam;
  return clamp(Math.floor(area / 56) + 2, 2, 48);
}

function getShipTier(entity) {
  const shape = getHullShape(entity);
  const deckLength = shape.shoulderX - shape.sternShoulderX;
  if (deckLength < 24) return 1;
  if (deckLength < 36) return 2;
  if (deckLength < 50) return 3;
  return 4;
}

function getShipWeaponCaps(entity, cannonCapacityBonus = 0) {
  const shape = getHullShape(entity);
  const tier = getShipTier(entity);
  const deckLength = shape.shoulderX - shape.sternShoulderX;
  const deckBeam = shape.beam * 1.16;
  const deckArea = deckLength * deckBeam;

  const baseCannonsPerSide = 2 + (tier - 1) * 2;
  const areaCannons = Math.max(0, Math.floor((deckArea - 28) / 72));
  const maxCannonsPerSide = clamp(baseCannonsPerSide + areaCannons + cannonCapacityBonus, 2, 16);

  const baseGuns = 3 + tier * 2;
  const areaGuns = Math.max(0, Math.floor((deckArea - 28) / 44));
  const maxGunners = clamp(baseGuns + areaGuns, 3, 24);

  return { tier, maxCannonsPerSide, maxGunners };
}

function clampPlayerCrewToDeck() {
  player.crew = clamp(player.crew, 1, getDeckCrewCapacity(player));
}

function getSpareCrewCapacity(entity = player) {
  const totalCrew = clamp(entity.crew || 0, 0, getDeckCrewCapacity(entity));
  const committed = Math.max(0, (entity.rowers || 0) + (entity.gunners || 0) + (entity.repairCrew || 0));
  return Math.max(0, totalCrew - committed);
}

function clampPlayerSupportCrewToDeck() {
  const maxByDeck = getDeckCrewCapacity(player);
  player.repairCrew = clamp(player.repairCrew || 0, 0, maxByDeck);
  const maxSupport = Math.max(0, player.crew - (player.rowers + player.gunners));
  player.repairCrew = Math.min(player.repairCrew, maxSupport);
}

function clampPlayerArmamentToHull() {
  const caps = getShipWeaponCaps(player, player.cannonCapacityBonus);
  player.cannons = clamp(player.cannons, 0, caps.maxCannonsPerSide);
  player.gunners = clamp(player.gunners, 1, caps.maxGunners);
}

function damagePlayer(amount) {
  if (amount <= 0) return;
  player.hp -= amount;
  player.repairSuppressed = Math.max(player.repairSuppressed || 0, 2.4);
}

function getHullUpperEdge(shape) {
  return [
    { x: shape.sternX, y: 0 },
    { x: shape.sternShoulderX, y: -shape.beam * 0.46 },
    { x: shape.shoulderX, y: -shape.beam * 0.62 },
    { x: shape.bowX, y: 0 }
  ];
}

function hullHalfWidthAt(shape, x) {
  const topA = { x: shape.bowX, y: 0 };
  const topB = { x: shape.shoulderX, y: -shape.beam * 0.62 };
  const topC = { x: shape.sternShoulderX, y: -shape.beam * 0.46 };
  const topD = { x: shape.sternX, y: 0 };

  const px = clamp(x, shape.sternX, shape.bowX);
  if (px >= topB.x) {
    const t = (px - topB.x) / Math.max(0.001, topA.x - topB.x);
    return Math.abs(topB.y + (topA.y - topB.y) * t);
  }
  if (px >= topC.x) {
    const t = (px - topC.x) / Math.max(0.001, topB.x - topC.x);
    return Math.abs(topC.y + (topB.y - topC.y) * t);
  }
  const t = (px - topD.x) / Math.max(0.001, topC.x - topD.x);
  return Math.abs(topD.y + (topC.y - topD.y) * t);
}

function samplePolyline(points, tNorm) {
  const lengths = [];
  let total = 0;
  for (let i = 0; i < points.length - 1; i++) {
    const dx = points[i + 1].x - points[i].x;
    const dy = points[i + 1].y - points[i].y;
    const seg = Math.hypot(dx, dy);
    lengths.push(seg);
    total += seg;
  }

  const clampedT = clamp(tNorm, 0, 1);
  let target = clampedT * total;
  for (let i = 0; i < lengths.length; i++) {
    const seg = lengths[i];
    if (target <= seg || i === lengths.length - 1) {
      const localT = seg <= 0.0001 ? 0 : target / seg;
      const a = points[i];
      const b = points[i + 1];
      const x = a.x + (b.x - a.x) * localT;
      const y = a.y + (b.y - a.y) * localT;
      const txRaw = b.x - a.x;
      const tyRaw = b.y - a.y;
      const tLen = Math.hypot(txRaw, tyRaw) || 1;
      return {
        x,
        y,
        tx: txRaw / tLen,
        ty: tyRaw / tLen
      };
    }
    target -= seg;
  }

  const last = points[points.length - 1];
  return { x: last.x, y: last.y, tx: 1, ty: 0 };
}

function getHullSideMount(shape, index, total, sideSign, trimStart = 0.1, trimEnd = 0.9) {
  const upperEdge = getHullUpperEdge(shape);
  const baseT = total <= 1 ? 0.5 : index / (total - 1);
  const pathT = trimStart + (trimEnd - trimStart) * baseT;
  const upper = samplePolyline(upperEdge, pathT);

  let px = upper.x;
  let py = upper.y;
  let tx = upper.tx;
  let ty = upper.ty;

  if (sideSign >= 0) {
    py = -py;
    ty = -ty;
  }

  let nx = -ty;
  let ny = tx;
  const nLen = Math.hypot(nx, ny) || 1;
  nx /= nLen;
  ny /= nLen;

  const desiredY = sideSign >= 0 ? 1 : -1;
  if (ny * desiredY < 0) {
    nx = -nx;
    ny = -ny;
  }

  return { x: px, y: py, nx, ny };
}

function drawPerimeterMount(mount, length, thickness, color) {
  ctx.save();
  ctx.translate(mount.x, mount.y);
  ctx.rotate(Math.atan2(mount.ny, mount.nx));
  ctx.fillStyle = color;
  ctx.fillRect(0, -thickness * 0.5, length, thickness);
  ctx.restore();
}

function drawPerimeterMountWithAim(mount, length, thickness, color, aimOffset = 0) {
  ctx.save();
  ctx.translate(mount.x, mount.y);
  ctx.rotate(Math.atan2(mount.ny, mount.nx) + aimOffset);
  ctx.fillStyle = color;
  ctx.fillRect(0, -thickness * 0.5, length, thickness);
  ctx.restore();
}

function getDistributedCannonMask(totalPorts, cannonPorts) {
  const total = Math.max(0, totalPorts);
  const cannons = clamp(cannonPorts, 0, total);
  const mask = new Array(total).fill(false);
  if (cannons <= 0 || total <= 0) return mask;

  for (let i = 0; i < cannons; i++) {
    let idx = Math.round(((i + 0.5) * total) / cannons - 0.5);
    idx = clamp(idx, 0, total - 1);
    while (mask[idx]) idx = (idx + 1) % total;
    mask[idx] = true;
  }
  return mask;
}

function getPlayerAutoTarget() {
  let target = null;
  let best = Infinity;

  for (const enemy of state.enemies) {
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 < best) {
      best = d2;
      target = enemy;
    }
  }

  for (const island of state.islands) {
    for (const building of island.buildings) {
      const dx = building.x - player.x;
      const dy = building.y - player.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < best) {
        best = d2;
        target = building;
      }
    }
  }

  if (!target) return null;

  const dx = target.x - player.x;
  const dy = target.y - player.y;
  const dist = Math.hypot(dx, dy);
  const forward = getForwardVector();
  const cross = forward.x * dy - forward.y * dx;
  return {
    target,
    dist,
    sideSign: cross >= 0 ? 1 : -1,
    targetAngle: Math.atan2(dy, dx)
  };
}

const GOLD_MAGNET_PULL_FACTOR = 0.62;
const GOLD_MAGNET_BASE_SPEED = 2.1;
let enemyIdSeed = 1;

function squadAnchor() {
  const candidates = state.enemies.filter((e) => e.kind !== 'boss' && e.kind !== 'rammer' && e.squadId != null);
  if (!candidates.length || Math.random() < 0.4) return Math.floor(Math.random() * 1000000);
  return candidates[Math.floor(Math.random() * candidates.length)].squadId;
}

function spawnShipExplosion(x, y, size, boss = false) {
  const shards = boss ? 34 : 20;
  for (let i = 0; i < shards; i++) {
    const ang = Math.random() * Math.PI * 2;
    const speed = (1.3 + Math.random() * (boss ? 5.4 : 4.1)) * 0.65;
    const life = 0.24 + Math.random() * (boss ? 0.54 : 0.42);
    const colorRoll = Math.random();
    const color = colorRoll < 0.34 ? '#ffe26a' : colorRoll < 0.67 ? '#ff9d2f' : '#e6452f';
    const sides = Math.random() < 0.55 ? 3 : 4;
    state.particles.push({
      x,
      y,
      vx: Math.cos(ang) * speed,
      vy: Math.sin(ang) * speed,
      size: (1.6 + Math.random() * 4.8) * (boss ? 1.2 : 1),
      rot: Math.random() * Math.PI * 2,
      spin: (Math.random() - 0.5) * (boss ? 0.65 : 0.48),
      life,
      maxLife: life,
      color,
      sides,
      drift: 0.14 + Math.random() * 0.22
    });
  }
}

function spawnMuzzleBlast(x, y, dirX, dirY, cannon = false) {
  const particles = window.GameParticleEffects.createMuzzleBlastParticles(x, y, dirX, dirY, cannon);
  state.particles.push(...particles);
}

function spawnImpactDebris(x, y, dirX, dirY, heavy = false, target = null) {
  const particles = window.GameParticleEffects.createImpactDebrisParticles(x, y, dirX, dirY, heavy, target);
  state.particles.push(...particles);
}

function spawnDeckBurst(x, y, dirX, dirY, heavy = false) {
  const particles = window.GameParticleEffects.createDeckBurstParticles(x, y, dirX, dirY, heavy);
  state.particles.push(...particles);
}

function enemyThreatTier(kind, stageIndex, difficultyTier) {
  if (kind === 'boss') return 5;
  const raw = 1 + Math.floor((stageIndex * 0.65 + difficultyTier) * 0.5);
  return clamp(raw + (kind === 'raider' ? 1 : 0), 1, 4);
}

function getEnemyVisualStyle(enemyId, kind, squadId, stageIndex, difficultyTier) {
  const threat = enemyThreatTier(kind, stageIndex, difficultyTier);

  if (kind === 'boss') {
    return {
      hullColor: '#7b2e3d',
      sailColor: '#f1d1d8',
      flagColor: '#a62c44',
      flagAccent: '#ffe0ea',
      flagStripes: 5,
      teamHue: 342
    };
  }

  const paletteByThreat = [
    { sail: '#d6e8f5', hull: '#3a5263', flag: '#4f89c2', accent: '#b7d6f1', hue: 205 },
    { sail: '#e8ddd0', hull: '#5a4a3d', flag: '#d08a39', accent: '#f4d5a8', hue: 32 },
    { sail: '#e7d6dd', hull: '#5d3f4f', flag: '#b44d74', accent: '#f3bfd1', hue: 332 },
    { sail: '#d7e8d6', hull: '#425940', flag: '#4c9d5b', accent: '#b7e6be', hue: 130 }
  ];

  if (squadId != null) {
    const hue = ((squadId * 53) % 360 + 360) % 360;
    const light = 74 - threat * 2;
    return {
      hullColor: `hsl(${hue} 26% 30%)`,
      sailColor: `hsl(${hue} 62% ${light}%)`,
      flagColor: `hsl(${hue} 72% 48%)`,
      flagAccent: `hsl(${hue} 76% 82%)`,
      flagStripes: threat,
      teamHue: hue
    };
  }

  const pick = paletteByThreat[(enemyId + threat) % paletteByThreat.length];
  return {
    hullColor: pick.hull,
    sailColor: pick.sail,
    flagColor: pick.flag,
    flagAccent: pick.accent,
    flagStripes: threat,
    teamHue: pick.hue
  };
}

function getBroadsideFirePlan(enemy, target) {
  const dx = target.x - enemy.x;
  const dy = target.y - enemy.y;
  const dist = Math.hypot(dx, dy);
  const targetAngle = Math.atan2(dy, dx);
  const fwd = { x: Math.cos(enemy.heading), y: Math.sin(enemy.heading) };
  const cross = fwd.x * dy - fwd.y * dx;
  const sideSign = cross >= 0 ? 1 : -1;
  const broadside = enemy.heading + sideSign * Math.PI / 2;
  const broadsideOffset = Math.abs(angleDiff(targetAngle, broadside));
  const cannonWindow = (enemy.cannonPivot + 12) * (Math.PI / 180);

  return {
    dist,
    targetAngle,
    sideSign,
    canLikelyHitGun: broadsideOffset <= 1.2,
    canLikelyHitCannon: broadsideOffset <= cannonWindow
  };
}

function pickBossTarget(enemy, playerPlan) {
  if (playerPlan.dist <= enemy.cannonRange * 1.08 && (playerPlan.canLikelyHitGun || playerPlan.canLikelyHitCannon)) {
    return { target: player, plan: playerPlan };
  }

  let fallback = null;
  let bestScore = Infinity;
  for (const other of state.enemies) {
    if (other === enemy || other.kind === 'boss') continue;
    const plan = getBroadsideFirePlan(enemy, other);
    if (plan.dist > enemy.cannonRange * 0.95) continue;
    if (!plan.canLikelyHitGun && !plan.canLikelyHitCannon) continue;
    const score = plan.dist + (plan.canLikelyHitCannon ? 0 : 45);
    if (score < bestScore) {
      bestScore = score;
      fallback = { target: other, plan };
    }
  }

  return fallback || { target: player, plan: playerPlan };
}

const upgradePool = [
  {
    name: 'Crew Musketeers',
    desc: '+1 crew, faster fire',
    apply() {
      player.crew += 1;
      player.gunners += 1;
      const caps = getShipWeaponCaps(player, player.cannonCapacityBonus);
      player.gunners = Math.min(player.gunners, caps.maxGunners);
      player.gunReload = Math.max(0.75, player.gunReload - 0.05);
      player.hullLength += 0.03;
      player.bowSharpness += 0.04;
      addAbility('Musketeers');
    }
  },
  {
    name: 'Cannons',
    desc: '+1 cannon, +damage',
    apply() {
      const caps = getShipWeaponCaps(player, player.cannonCapacityBonus);
      if (player.cannons < caps.maxCannonsPerSide) {
        player.cannons += 1;
      }
      player.bulletDamage += 3;
      player.cannonReload = Math.max(1.0, player.cannonReload - 0.1);
      player.hullBeam += 0.03;
      addAbility('Cannons');
    }
  },
  {
    name: 'Cannon Installments',
    desc: '+1 cannon capacity/side, heavier hull',
    apply() {
      player.cannonCapacityBonus += 1;
      player.size += 1.4;
      player.mass += 4;
      player.hullBeam += 0.06;
      player.hullLength += 0.04;
      player.baseSpeed = Math.max(1.6, player.baseSpeed - 0.08);
      player.maneuverPenalty = clamp(player.maneuverPenalty + 0.04, 0, 0.42);
      addAbility('Installments');
    }
  },
  {
    name: 'Rowers',
    desc: '+1 rower, wind mitigation',
    apply() {
      player.rowers += 1;
      player.baseSpeed += 0.16;
      player.hullLength += 0.02;
      addAbility('Rowers');
    }
  },
  {
    name: 'Repair Crew',
    desc: '+1 repair crew, passive hull regen',
    apply() {
      const deckCap = getDeckCrewCapacity(player);
      let spare = getSpareCrewCapacity(player);
      if (spare <= 0 && player.crew < deckCap) {
        player.crew += 1;
        spare = getSpareCrewCapacity(player);
      }
      if (spare > 0) {
        player.repairCrew += 1;
        clampPlayerSupportCrewToDeck();
      }
      addAbility('RepairCrew');
    }
  },
  {
    name: 'Reinforced Hull',
    desc: '+15 max HP and heal 10',
    apply() {
      player.maxHp += 15;
      player.hp = Math.min(player.maxHp, player.hp + 10);
      player.hullBeam += 0.05;
      player.sternTaper -= 0.03;
      addAbility('Hull');
    }
  },
  {
    name: 'Ram Bow',
    desc: 'Ramming enabled, +size',
    apply() {
      player.ram = true;
      player.size += 2;
      player.bowSharpness += 0.14;
      addAbility('Ram');
    }
  },
  {
    name: 'Sail Mastery',
    desc: '+speed, bigger ship',
    apply() {
      player.baseSpeed += 0.25;
      player.size += 1;
      player.mass += 2;
      player.hullLength += 0.05;
      player.hullBeam -= 0.03;
      addAbility('Sails');
    }
  },
  {
    name: 'Rudder Upgrade',
    desc: 'Turn faster under momentum',
    apply() {
      player.rudder += 1;
      addAbility('Rudder');
    }
  },
  {
    name: 'Cannon Trunnions',
    desc: 'Cannons can auto-pivot +5°',
    apply() {
      player.cannonPivot = Math.min(20, player.cannonPivot + 5);
      addAbility('PivotCannons');
    }
  }
];

const majorUpgradePool = [
  {
    name: 'Dreadnought Hull',
    desc: 'Massive hull growth, +40 max HP',
    apply() {
      player.size += 5;
      player.maxHp += 40;
      player.hp = Math.min(player.maxHp, player.hp + 28);
      player.mass += 10;
      player.hullBeam += 0.12;
      player.sternTaper -= 0.06;
      player.hullColor = '#3f2f24';
      player.trimColor = '#c7a476';
      addAbility('Dreadnought');
    }
  },
  {
    name: 'Crimson Sails',
    desc: 'Faster ship, faster volleys',
    apply() {
      player.baseSpeed += 0.45;
      player.gunReload = Math.max(0.8, player.gunReload - 0.04);
      player.cannonReload = Math.max(0.9, player.cannonReload - 0.1);
      player.hullLength += 0.08;
      player.hullBeam -= 0.06;
      player.bowSharpness += 0.08;
      player.sailColor = '#d34d4d';
      player.mastScale += 0.2;
      addAbility('CrimsonSails');
    }
  },
  {
    name: 'Grand Broadside',
    desc: '+2 cannons, +10 damage',
    apply() {
      player.cannons += 2;
      player.bulletDamage += 10;
      player.size += 1;
      player.mass += 3;
      player.hullBeam += 0.08;
      addAbility('Broadside');
    }
  },
  {
    name: 'Iron Ram Prow',
    desc: 'Deadlier collisions, ram visual',
    apply() {
      player.ram = true;
      player.ramDamage += 38;
      player.size += 2;
      player.mass += 4;
      player.bowSharpness += 0.18;
      player.hullLength += 0.06;
      player.hullColor = '#4a3a2e';
      addAbility('IronRam');
    }
  }
];

function addAbility(label) {
  if (player.slots.length < 4 && !player.slots.includes(label)) {
    player.slots.push(label);
  }
}

function initWorld() {
  const islandCount = 24;
  for (let i = 0; i < islandCount; i++) {
    const x = 200 + Math.random() * (state.world.width - 400);
    const y = 200 + Math.random() * (state.world.height - 400);
    const roll = Math.random();
    const isSmall = roll < 0.22;
    const isLong = roll >= 0.22 && roll < 0.5;
    const isLarge = roll > 0.84;
    const r = isSmall ? (28 + Math.random() * 36) : isLarge ? (96 + Math.random() * 82) : (50 + Math.random() * 76);
    const island = { x, y, r, patches: [], buildings: [], docks: [], defenseLevel: 0 };

    const patchCount = isSmall ? (5 + Math.floor(Math.random() * 4)) : isLarge ? (18 + Math.floor(Math.random() * 12)) : (9 + Math.floor(Math.random() * 10));
    const spineDir = Math.random() * Math.PI * 2;
    const spineLength = isLong ? (r * (1.6 + Math.random() * 1.4)) : (r * (0.4 + Math.random() * 0.5));
    const thickness = isLong ? (0.22 + Math.random() * 0.18) : (0.45 + Math.random() * 0.28);
    let maxExtent = r;

    for (let p = 0; p < patchCount; p++) {
      const t = patchCount <= 1 ? 0.5 : (p / (patchCount - 1));
      const along = (t - 0.5) * spineLength;
      const lateral = (Math.random() - 0.5) * r * thickness;
      const px = x + Math.cos(spineDir) * along - Math.sin(spineDir) * lateral + (Math.random() - 0.5) * r * 0.22;
      const py = y + Math.sin(spineDir) * along + Math.cos(spineDir) * lateral + (Math.random() - 0.5) * r * 0.22;
      const size = (isSmall ? 8 : isLarge ? 14 : 10) + Math.random() * (isLarge ? 22 : 16);
      const sides = Math.random() < 0.58 ? 6 : 3;
      const rot = Math.random() * Math.PI * 2;
      island.patches.push({ x: px, y: py, size, sides, rot });
      maxExtent = Math.max(maxExtent, Math.hypot(px - x, py - y) + size * 1.2);

      if (Math.random() < 0.35) {
        const offAng = Math.random() * Math.PI * 2;
        const offDist = size * (0.4 + Math.random() * 0.7);
        const sx = px + Math.cos(offAng) * offDist;
        const sy = py + Math.sin(offAng) * offDist;
        const ssize = size * (0.45 + Math.random() * 0.4);
        const ssides = Math.random() < 0.5 ? 6 : 3;
        island.patches.push({ x: sx, y: sy, size: ssize, sides: ssides, rot: rot + Math.random() * 0.6 });
        maxExtent = Math.max(maxExtent, Math.hypot(sx - x, sy - y) + ssize * 1.2);
      }
    }

    if (isLarge && Math.random() < 0.55) {
      const subCount = 5 + Math.floor(Math.random() * 5);
      for (let s = 0; s < subCount; s++) {
        const ang = Math.random() * Math.PI * 2;
        const dist = r * (0.65 + Math.random() * 0.35);
        const px = x + Math.cos(ang) * dist;
        const py = y + Math.sin(ang) * dist;
        const size = 12 + Math.random() * 18;
        const sides = Math.random() < 0.5 ? 6 : 3;
        const rot = Math.random() * Math.PI * 2;
        island.patches.push({ x: px, y: py, size, sides, rot });
        maxExtent = Math.max(maxExtent, Math.hypot(px - x, py - y) + size * 1.2);
      }
    }

    island.r = maxExtent;

    const bCount = Math.max(2, Math.floor(island.r / 24));
    for (let b = 0; b < bCount; b++) {
      const patch = island.patches[Math.floor(Math.random() * island.patches.length)];
      const bx = patch.x + (Math.random() - 0.5) * patch.size * 0.6;
      const by = patch.y + (Math.random() - 0.5) * patch.size * 0.6;
      const size = 8 + Math.random() * 18;
      island.buildings.push({
        x: bx,
        y: by,
        size,
        hp: 18 + size * 1.6,
        maxHp: 18 + size * 1.6,
        tower: false,
        fireTimer: Math.random()
      });
    }

    if (island.buildings.length) {
      const dockCount = 1 + Math.floor(Math.random() * (isLarge ? 3 : 2));
      for (let d = 0; d < dockCount; d++) {
        const ang = Math.random() * Math.PI * 2;
        const baseDist = island.r * (0.78 + Math.random() * 0.15);
        const length = 18 + Math.random() * 34;
        const width = 6 + Math.random() * 5;
        island.docks.push({
          x: island.x + Math.cos(ang) * baseDist,
          y: island.y + Math.sin(ang) * baseDist,
          rot: ang,
          length,
          width
        });
      }
    }

    state.islands.push(island);
  }

  for (let i = 0; i < 11; i++) {
    state.clouds.push({
      x: Math.random() * state.world.width,
      y: Math.random() * state.world.height,
      w: 130 + Math.random() * 180,
      h: 45 + Math.random() * 60,
      drift: 0.2 + Math.random() * 0.35
    });
  }
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function polygonPath(cx, cy, radius, sides, rot) {
  ctx.beginPath();
  for (let i = 0; i < sides; i++) {
    const a = rot + (i / sides) * Math.PI * 2;
    const px = cx + Math.cos(a) * radius;
    const py = cy + Math.sin(a) * radius;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
}

function angleDiff(a, b) {
  return Math.atan2(Math.sin(a - b), Math.cos(a - b));
}

function updateCamera() {
  const viewW = canvas.width / state.zoom;
  const viewH = canvas.height / state.zoom;
  state.camera.x = clamp(player.x - viewW / 2, 0, Math.max(0, state.world.width - viewW));
  state.camera.y = clamp(player.y - viewH / 2, 0, Math.max(0, state.world.height - viewH));
}

function toScreen(wx, wy) {
  return {
    x: (wx - state.camera.x) * state.zoom,
    y: (wy - state.camera.y) * state.zoom
  };
}

function ensureIslandDefenses() {
  const targetTier = Math.floor((state.difficultyTier + state.difficultyFromSize) / 2);
  if (targetTier <= state.defenseTier) return;
  state.defenseTier = targetTier;

  for (const island of state.islands) {
    const towerChance = clamp(0.18 + targetTier * 0.08, 0.18, 0.85);
    island.defenseLevel = targetTier;
    for (const b of island.buildings) {
      if (!b.tower && Math.random() < towerChance) {
        b.tower = true;
        b.hp += 14 + targetTier * 4;
        b.maxHp = b.hp;
      }
    }
  }
}

function simulateVessel(entity, dt, input) {
  const fwd = { x: Math.cos(entity.heading), y: Math.sin(entity.heading) };
  const windMag = Math.hypot(state.wind.x, state.wind.y) || 1;
  const windDir = { x: state.wind.x / windMag, y: state.wind.y / windMag };

  const rowPower = input.rowing ? (0.12 + entity.rowers * 0.06) : 0;
  const sailAlignment = entity.sailOpen ? Math.max(0, fwd.x * windDir.x + fwd.y * windDir.y) : 0;
  const sailPush = entity.sailOpen ? sailAlignment * (0.1 + entity.size * 0.0015) : 0;
  const drag = input.brake ? 0.052 : 0.018;
  const accel = (rowPower + sailPush) / Math.max(1, entity.mass / 16);
  const pace = dt * 12;

  entity.speed += accel * pace;
  entity.speed -= drag * entity.speed * pace;
  entity.speed = clamp(entity.speed, 0, entity.baseSpeed + 1.6);

  const steer = 0.011 + entity.rudder * 0.005 + entity.rowers * 0.0015;
  const speedFactor = 0.3 + Math.min(1.1, entity.speed / 2.3);
  if (input.turnLeft) entity.heading -= steer * speedFactor * pace;
  if (input.turnRight) entity.heading += steer * speedFactor * pace;

  const rowerMitigation = Math.min(0.82, entity.rowers * 0.14);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  entity.x += fwd.x * entity.speed * pace + wx * dt * 5.2;
  entity.y += fwd.y * entity.speed * pace + wy * dt * 5.2;
  entity.x = clamp(entity.x, 24, state.world.width - 24);
  entity.y = clamp(entity.y, 24, state.world.height - 24);
}

function resolveIslandCollisions(entity, dt, playerCollision = false) {
  for (const island of state.islands) {
    const centerDist = Math.hypot(entity.x - island.x, entity.y - island.y);
    if (centerDist > island.r + entity.size + 20) continue;

    for (const patch of island.patches) {
      const dx = entity.x - patch.x;
      const dy = entity.y - patch.y;
      const d = Math.hypot(dx, dy) || 1;
      const minDist = patch.size * 0.82 + entity.size * 0.62;
      if (d < minDist) {
        const nx = dx / d;
        const ny = dy / d;
        const push = minDist - d + 0.1;
        entity.x += nx * push;
        entity.y += ny * push;
        entity.speed *= 0.25;

        if (playerCollision) {
          const impact = 3.5 + entity.mass * 0.03;
          damagePlayer(impact * dt * 0.5);
        }
      }
    }
  }
}

function getShoreAvoidanceVector(entity, influence = 180) {
  let ax = 0;
  let ay = 0;
  for (const island of state.islands) {
    const dx = entity.x - island.x;
    const dy = entity.y - island.y;
    const d = Math.hypot(dx, dy) || 1;
    const safe = island.r + influence + entity.size * 0.6;
    if (d >= safe) continue;
    const t = clamp((safe - d) / safe, 0, 1);
    const push = t * t * 2.2;
    ax += (dx / d) * push;
    ay += (dy / d) * push;
  }
  return { x: ax, y: ay };
}

function applyShoreRepulsion(entity, dt, strength = 1) {
  const avoid = getShoreAvoidanceVector(entity, 170);
  if (!avoid.x && !avoid.y) return;
  entity.x += avoid.x * dt * 60 * strength;
  entity.y += avoid.y * dt * 60 * strength;
  entity.speed *= 1 - clamp((Math.hypot(avoid.x, avoid.y) * 0.035), 0, 0.16);
}

function getVesselSeparationVector(entity) {
  const ownLen = Math.max(10, getHullDims(entity).len);
  let ax = 0;
  let ay = 0;

  const boats = [player, ...state.enemies];
  for (const other of boats) {
    if (other === entity) continue;

    const dx = entity.x - other.x;
    const dy = entity.y - other.y;
    const d = Math.hypot(dx, dy) || 1;

    const otherLen = Math.max(10, getHullDims(other).len);
    const hardBody = collisionRadius(entity) + collisionRadius(other);
    const desiredGap = Math.max(ownLen, hardBody + ownLen * 0.2, ownLen * 0.65 + otherLen * 0.35);
    if (d >= desiredGap) continue;

    const t = clamp((desiredGap - d) / desiredGap, 0, 1);
    const push = t * t * 2.5;
    ax += (dx / d) * push;
    ay += (dy / d) * push;
  }

  return { x: ax, y: ay };
}

function seeded01(seed) {
  const s = Math.sin(seed * 12.9898 + 78.233) * 43758.5453;
  return s - Math.floor(s);
}

function drawDeckDamageMarks(entity, hull, zoomScale = 1) {
  const maxHp = Math.max(1, entity.maxHp || 1);
  const hp = clamp(entity.hp || maxHp, 0, maxHp);
  const damage = 1 - hp / maxHp;
  if (damage <= 0.05) return;

  const marks = Math.max(1, Math.floor(damage * 22));
  const seedBase = entity.damageSeed || entity.id || 101;
  const minX = hull.sternShoulderX * 0.88;
  const maxX = hull.shoulderX * 0.92;

  ctx.fillStyle = '#141516';
  for (let i = 0; i < marks; i++) {
    const r1 = seeded01(seedBase + i * 1.37);
    const r2 = seeded01(seedBase + i * 4.21 + 19.1);
    const r3 = seeded01(seedBase + i * 7.13 + 3.6);
    const r4 = seeded01(seedBase + i * 9.71 + 44.2);
    const x = minX + (maxX - minX) * r1;
    const halfW = hullHalfWidthAt(hull, x) * (0.58 + r2 * 0.14);
    const y = (r3 * 2 - 1) * halfW;
    const size = (1.2 + r4 * 2.5) * zoomScale;
    polygonPath(x, y, size, r1 > 0.5 ? 4 : 3, r2 * Math.PI * 2);
    ctx.fill();
  }
}

function spawnEnemy() {
  const cfg = getLevelConfig(state.stageIndex);
  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12 + state.difficultyFromSize * 0.09;

  const edge = Math.floor(Math.random() * 4);
  const margin = 130;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(20, Math.min(state.world.width - 20, x));
  y = Math.max(20, Math.min(state.world.height - 20, y));

  const t = Math.random();
  let kind = 'pirate';
  if (t > 0.66) kind = 'raider';
  if (t > 0.9) kind = 'rammer';

  const quality = 1 + state.difficultyTier * 0.045 + state.stageIndex * 0.02 + Math.random() * 0.24;
  const profileSeed = Math.random();
  const artilleryBias = profileSeed < 0.33 ? 1.35 : profileSeed < 0.66 ? 1.0 : 0.72;
  const speedBias = profileSeed > 0.6 ? 1.15 : 0.92 + Math.random() * 0.2;
  const hullLength = 0.9 + Math.random() * 0.3;
  const hullBeam = 0.86 + Math.random() * 0.3;
  const bowSharpness = 0.9 + Math.random() * 0.45;
  const sternTaper = 0.78 + Math.random() * 0.42;

  const base = (12 + state.level * 1.2) * difficultyMult;
  const size = ((kind === 'raider' ? 18 : kind === 'rammer' ? 13 : 15) + state.difficultyFromSize * 0.45) * (0.95 + Math.random() * 0.15);
  const hp = base * (kind === 'raider' ? 2.1 : kind === 'rammer' ? 1.4 : 1);
  const baseSpeed = (kind === 'rammer' ? 2.3 : kind === 'raider' ? 1.45 : 1.75) * (1 + cfg.spawnRate * 0.04) * speedBias;
  const enemyCaps = getShipWeaponCaps({
    size,
    hullLength,
    hullBeam,
    bowSharpness,
    sternTaper
  }, Math.floor(state.difficultyTier / 4));

  const cannons = clamp(
    Math.max(0, Math.floor(state.difficultyTier / 2) + (kind === 'raider' ? 1 : 0) + Math.floor(Math.random() * (0.4 + artilleryBias * 1.6))),
    0,
    enemyCaps.maxCannonsPerSide
  );
  const gunners = clamp(
    Math.max(1, 1 + Math.floor(state.difficultyTier / 2) + (kind === 'raider' ? 2 : 1) + Math.floor(Math.random() * 2)),
    1,
    enemyCaps.maxGunners
  );
  const rowers = 1 + Math.floor(state.stageIndex / 2) + (kind === 'rammer' ? 2 : 0);
  const cannonPivot = clamp((Math.floor(state.difficultyTier / 3) * 5) + (Math.random() < 0.32 ? 5 : 0) + Math.floor(Math.random() * 6), 0, 26);
  const squadId = (kind === 'pirate' || kind === 'raider') ? squadAnchor() : null;
  const enemyId = enemyIdSeed++;
  const style = getEnemyVisualStyle(enemyId, kind, squadId, state.stageIndex, state.difficultyTier);

  state.enemies.push({
    id: enemyId,
    x,
    y,
    hp,
    maxHp: hp,
    size,
    kind,
    squadId,
    heading: Math.random() * Math.PI * 2,
    speed: 0,
    baseSpeed,
    rowers,
    sailOpen: true,
    gunners,
    cannons,
    cannonPivot,
    rudder: kind === 'rammer' ? 2 : 1,
    mass: 20 + size * 0.9,
    gunReload: Math.max(0.66, (1.3 - state.difficultyTier * 0.035) * (1.08 - (quality - 1) * 0.18)),
    cannonReload: Math.max(0.92, (2.1 - state.difficultyTier * 0.05) * (1.12 - (quality - 1) * 0.26)),
    gunTimer: Math.random() * 0.8,
    cannonTimer: Math.random() * 1.2,
    gunRange: 102 + size * 3.0 + state.difficultyTier * 7 + Math.random() * 22,
    cannonRange: Math.max(158 + size * 4.5 + cannons * 14 + state.difficultyTier * 9 + Math.random() * 26, 102 + size * 3.0 + state.difficultyTier * 7 + 55),
    bulletDamage: (5 + state.difficultyTier * 1.5 + cannons * 1.2) * quality,
    gunSpeed: 4.35 + Math.random() * 0.65,
    cannonSpeed: 3.95 + Math.random() * 0.55,
    gunSpread: 0.18 + Math.random() * 0.09,
    cannonSpread: 0.07 + Math.random() * 0.06,
    hullLength,
    hullBeam,
    bowSharpness,
    sternTaper,
    impactTimer: 0,
    hullColor: style.hullColor,
    sailColor: style.sailColor,
    flagColor: style.flagColor,
    flagAccent: style.flagAccent,
    flagStripes: style.flagStripes,
    teamHue: style.teamHue
  });
}

function spawnBoss() {
  const edge = Math.floor(Math.random() * 4);
  const margin = 170;
  let x, y;
  if (edge === 0) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y - margin; }
  if (edge === 1) { x = state.camera.x + canvas.width + margin; y = state.camera.y + Math.random() * canvas.height; }
  if (edge === 2) { x = state.camera.x + Math.random() * canvas.width; y = state.camera.y + canvas.height + margin; }
  if (edge === 3) { x = state.camera.x - margin; y = state.camera.y + Math.random() * canvas.height; }

  x = Math.max(30, Math.min(state.world.width - 30, x));
  y = Math.max(30, Math.min(state.world.height - 30, y));

  const hp = 260 + state.level * 18 + state.difficultyTier * 45;
  const size = 30 + state.difficultyTier * 1.2 + state.difficultyFromSize * 0.6;
  const bossId = enemyIdSeed++;
  const style = getEnemyVisualStyle(bossId, 'boss', null, state.stageIndex, state.difficultyTier);

  state.enemies.push({
    id: bossId,
    x,
    y,
    hp,
    maxHp: hp,
    size,
    kind: 'boss',
    squadId: null,
    heading: Math.random() * Math.PI * 2,
    speed: 0,
    baseSpeed: 1.2 + state.difficultyTier * 0.06,
    rowers: 3 + Math.floor(state.difficultyTier / 2),
    sailOpen: true,
    gunners: 4 + state.difficultyTier,
    cannons: 4 + Math.floor(state.difficultyTier / 2),
    cannonPivot: clamp(5 + Math.floor(state.difficultyTier / 2) * 5, 5, 25),
    rudder: 2,
    mass: 46 + size,
    gunReload: Math.max(0.78, 1.25 - state.difficultyTier * 0.03),
    cannonReload: Math.max(0.82, 1.45 - state.difficultyTier * 0.04),
    gunTimer: 0.4,
    cannonTimer: 0.7,
    gunRange: 150 + size * 3.3,
    cannonRange: Math.max(245 + size * 4.8 + state.difficultyTier * 14, 150 + size * 3.3 + 80),
    bulletDamage: 10 + state.difficultyTier * 2.4,
    hullLength: 1 + Math.random() * 0.25,
    hullBeam: 1 + Math.random() * 0.2,
    bowSharpness: 1 + Math.random() * 0.3,
    sternTaper: 0.82 + Math.random() * 0.28,
    impactTimer: 0,
    hullColor: style.hullColor,
    sailColor: style.sailColor,
    flagColor: style.flagColor,
    flagAccent: style.flagAccent,
    flagStripes: style.flagStripes,
    teamHue: style.teamHue
  });
}

function getForwardVector() {
  return { x: Math.cos(player.heading), y: Math.sin(player.heading) };
}

function getRightVector() {
  const f = getForwardVector();
  return { x: -f.y, y: f.x };
}
audioSystem = window.GameAudioSystem.createGameAudioSystem({
  getPlayerPosition: () => ({ x: player.x, y: player.y }),
  getForwardVector,
  getRightVector,
  button: audioToggleBtn,
  clamp
});

const normalizeOr = window.GameAudioSystem.normalizeOr;

function playGunVolleySfx(originX, originY, dirX, dirY, count = 1, sourceSize = 16) {
  audioSystem.playGunVolleySfx(originX, originY, dirX, dirY, count, sourceSize);
}

function playCannonVolleySfx(originX, originY, dirX, dirY, count = 1, sourceSize = 16) {
  audioSystem.playCannonVolleySfx(originX, originY, dirX, dirY, count, sourceSize);
}

function playGunImpactSfx(originX, originY, dirX, dirY, sourceSize = 16) {
  audioSystem.playGunImpactSfx(originX, originY, dirX, dirY, sourceSize);
}

function playCannonImpactSfx(originX, originY, dirX, dirY, sourceSize = 16) {
  audioSystem.playCannonImpactSfx(originX, originY, dirX, dirY, sourceSize);
}

function broadsideFire(sideSign, target, distanceToTarget, allowGunFire, allowCannonFire) {
  const right = getRightVector();
  const forward = getForwardVector();
  const shape = getHullShape(player);
  const guns = Math.max(2, player.gunners + player.cannons);
  const cannonSlots = Math.min(guns, player.cannons);
  const cannonMask = getDistributedCannonMask(guns, cannonSlots);
  const isCannon = (portIndex) => cannonMask[portIndex];
  const ranges = getPlayerRanges();
  const allowGun = distanceToTarget <= ranges.gun && allowGunFire;
  const allowCannon = distanceToTarget <= ranges.cannon && allowCannonFire;

  if (!allowGun && !allowCannon) return { firedGun: false, firedCannon: false };

  const baseDir = player.heading + sideSign * Math.PI / 2;
  const targetAngle = target ? Math.atan2(target.y - player.y, target.x - player.x) : baseDir;
  const pivotRad = player.cannonPivot * (Math.PI / 180);
  let firedGun = false;
  let firedCannon = false;
  let gunCount = 0;
  let cannonCount = 0;
  let gunDirX = 0;
  let gunDirY = 0;
  let cannonDirX = 0;
  let cannonDirY = 0;

  for (let i = 0; i < guns; i++) {
    const cannonPort = isCannon(i);
    if (cannonPort && !allowCannon) continue;
    if (!cannonPort && !allowGun) continue;

    const mount = getHullSideMount(shape, i, guns, sideSign, 0.12, 0.88);
    const mountLen = cannonPort ? Math.max(8, player.size * 0.48) : Math.max(4.5, player.size * 0.3);
    const muzzleLift = mountLen + (cannonPort ? 0.7 : 0.35);
    const localX = mount.x + mount.nx * muzzleLift;
    const localY = mount.y + mount.ny * muzzleLift;
    const spawnX = player.x + forward.x * localX + right.x * localY;
    const spawnY = player.y + forward.y * localX + right.y * localY;

    const spread = (Math.random() - 0.5) * (cannonPort ? 0.12 : 0.18);
    const mountWorldAngle = player.heading + Math.atan2(mount.ny, mount.nx);
    const gunAdjust = clamp(angleDiff(targetAngle, mountWorldAngle), -36 * (Math.PI / 180), 36 * (Math.PI / 180));
    const cannonAdjust = clamp(angleDiff(targetAngle, mountWorldAngle), -pivotRad, pivotRad);
    const dir = cannonPort ? (mountWorldAngle + cannonAdjust + spread) : (mountWorldAngle + gunAdjust + spread);
    const speed = player.bulletSpeed + (cannonPort ? 0.45 : 0.2);
    const dmg = player.bulletDamage + (cannonPort ? 4 : 0);

    state.bullets.push({
      x: spawnX,
      y: spawnY,
      vx: Math.cos(dir) * speed,
      vy: Math.sin(dir) * speed,
      dmg,
      heavy: cannonPort,
      owner: 'player',
      sourceSize: player.size
    });
    spawnMuzzleBlast(spawnX, spawnY, Math.cos(dir), Math.sin(dir), cannonPort);
    if (cannonPort) {
      firedCannon = true;
      cannonCount += 1;
      cannonDirX += Math.cos(dir);
      cannonDirY += Math.sin(dir);
    } else {
      firedGun = true;
      gunCount += 1;
      gunDirX += Math.cos(dir);
      gunDirY += Math.sin(dir);
    }
  }

  if (firedGun && gunCount > 0) {
    const len = Math.hypot(gunDirX, gunDirY) || 1;
    playGunVolleySfx(player.x, player.y, gunDirX / len, gunDirY / len, gunCount, player.size);
  }
  if (firedCannon && cannonCount > 0) {
    const len = Math.hypot(cannonDirX, cannonDirY) || 1;
    playCannonVolleySfx(player.x, player.y, cannonDirX / len, cannonDirY / len, cannonCount, player.size);
  }

  return { firedGun, firedCannon };
}

function enemyVolley(enemy, target, sideSign, distanceToTarget, allowGunFire, allowCannonFire) {
  const fwd = { x: Math.cos(enemy.heading), y: Math.sin(enemy.heading) };
  const right = { x: -fwd.y, y: fwd.x };
  const shape = getHullShape(enemy);
  const targetAngle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
  const allowGun = distanceToTarget <= enemy.gunRange && allowGunFire;
  const allowCannon = distanceToTarget <= enemy.cannonRange && allowCannonFire;
  let firedGun = false;
  let firedCannon = false;
  let gunCount = 0;
  let cannonCount = 0;
  let gunDirX = 0;
  let gunDirY = 0;
  let cannonDirX = 0;
  let cannonDirY = 0;
  const baseDir = enemy.heading + sideSign * Math.PI / 2;

  if (allowGun) {
    const gunPorts = Math.max(1, enemy.gunners);
    for (let i = 0; i < gunPorts; i++) {
      const mount = getHullSideMount(shape, i, gunPorts, sideSign, 0.12, 0.88);
      const mountLen = Math.max(4, enemy.size * 0.28);
      const localX = mount.x + mount.nx * (mountLen + 0.3);
      const localY = mount.y + mount.ny * (mountLen + 0.3);
      const spawnX = enemy.x + fwd.x * localX + right.x * localY;
      const spawnY = enemy.y + fwd.y * localX + right.y * localY;
      const gunAdjust = clamp(angleDiff(targetAngle, baseDir), -44 * (Math.PI / 180), 44 * (Math.PI / 180));
      const dir = baseDir + gunAdjust + (Math.random() - 0.5) * (enemy.gunSpread || 0.2);
      state.bullets.push({
        x: spawnX,
        y: spawnY,
        vx: Math.cos(dir) * (enemy.gunSpeed || 4.6),
        vy: Math.sin(dir) * (enemy.gunSpeed || 4.6),
        dmg: enemy.bulletDamage * 0.48,
        heavy: false,
        owner: 'enemy',
        shooterId: enemy.id,
        sourceKind: enemy.kind,
        sourceSize: enemy.size
      });
      spawnMuzzleBlast(spawnX, spawnY, Math.cos(dir), Math.sin(dir), false);
      firedGun = true;
      gunCount += 1;
      gunDirX += Math.cos(dir);
      gunDirY += Math.sin(dir);
    }
  }

  if (allowCannon) {
    const cannonPorts = Math.max(0, enemy.cannons);
    const clamped = clamp(angleDiff(targetAngle, baseDir), -enemy.cannonPivot * (Math.PI / 180), enemy.cannonPivot * (Math.PI / 180));
    for (let i = 0; i < cannonPorts; i++) {
      const mount = getHullSideMount(shape, i, cannonPorts, sideSign, 0.16, 0.84);
      const mountLen = Math.max(7, enemy.size * 0.42);
      const localX = mount.x + mount.nx * (mountLen + 0.45);
      const localY = mount.y + mount.ny * (mountLen + 0.45);
      const spawnX = enemy.x + fwd.x * localX + right.x * localY;
      const spawnY = enemy.y + fwd.y * localX + right.y * localY;
      const dir = baseDir + clamped + (Math.random() - 0.5) * (enemy.cannonSpread || 0.1);
      state.bullets.push({
        x: spawnX,
        y: spawnY,
        vx: Math.cos(dir) * (enemy.cannonSpeed || 4.1),
        vy: Math.sin(dir) * (enemy.cannonSpeed || 4.1),
        dmg: enemy.bulletDamage,
        heavy: true,
        owner: 'enemy',
        shooterId: enemy.id,
        sourceKind: enemy.kind,
        sourceSize: enemy.size
      });
      spawnMuzzleBlast(spawnX, spawnY, Math.cos(dir), Math.sin(dir), true);
      firedCannon = true;
      cannonCount += 1;
      cannonDirX += Math.cos(dir);
      cannonDirY += Math.sin(dir);
    }
  }

  if (firedGun && gunCount > 0) {
    const len = Math.hypot(gunDirX, gunDirY) || 1;
    playGunVolleySfx(enemy.x, enemy.y, gunDirX / len, gunDirY / len, gunCount, enemy.size);
  }
  if (firedCannon && cannonCount > 0) {
    const len = Math.hypot(cannonDirX, cannonDirY) || 1;
    playCannonVolleySfx(enemy.x, enemy.y, cannonDirX / len, cannonDirY / len, cannonCount, enemy.size);
  }

  return { firedGun, firedCannon };
}

function shootAtNearest() {
  const aim = getPlayerAutoTarget();
  state.playerAim = aim;
  if (!aim) return { firedGun: false, firedCannon: false };

  const ranges = getPlayerRanges();
  if (aim.dist > Math.max(ranges.gun, ranges.cannon)) return { firedGun: false, firedCannon: false };
  const canGun = player.gunTimer >= player.gunReload;
  const canCannon = player.cannonTimer >= player.cannonReload;
  if (!canGun && !canCannon) return { firedGun: false, firedCannon: false };
  return broadsideFire(aim.sideSign, aim.target, aim.dist, canGun, canCannon);
}

function offerUpgrades() {
  const shuffled = [...upgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Choose an Upgrade',
    options: shuffled,
    major: false
  };
}

function offerMajorUpgrades() {
  const shuffled = [...majorUpgradePool].sort(() => Math.random() - 0.5).slice(0, 3);
  state.upgradesOffered = {
    title: 'Boss Defeated — Choose a Major Upgrade',
    options: shuffled,
    major: true
  };
}

function getUpgradeCardInfo(upgrade) {
  let desc = upgrade.desc;
  let blocked = false;

  if (upgrade.name === 'Cannons') {
    const caps = getShipWeaponCaps(player, player.cannonCapacityBonus);
    if (player.cannons >= caps.maxCannonsPerSide) {
      blocked = true;
      desc = `At cap ${player.cannons}/${caps.maxCannonsPerSide} per side. Take Cannon Installments to expand.`;
    } else {
      desc = `${upgrade.desc} (${Math.min(caps.maxCannonsPerSide, player.cannons + 1)}/${caps.maxCannonsPerSide} per side)`;
    }
  }

  if (upgrade.name === 'Cannon Installments') {
    const current = getShipWeaponCaps(player, player.cannonCapacityBonus);
    const next = getShipWeaponCaps(player, player.cannonCapacityBonus + 1);
    desc = `${upgrade.desc} (${current.maxCannonsPerSide}→${next.maxCannonsPerSide} per side)`;
  }

  if (upgrade.name === 'Repair Crew') {
    const spare = getSpareCrewCapacity(player);
    if (spare <= 0 && player.crew >= getDeckCrewCapacity(player)) {
      blocked = true;
      desc = `No crew slots free. Increase deck/crew capacity first (${player.crew}/${getDeckCrewCapacity(player)}).`;
    } else {
      const effective = player.repairCrew + (spare > 0 ? 1 : 1);
      const approxPerSec = (0.36 + effective * 0.3).toFixed(1);
      desc = `${upgrade.desc} (Repair crew ${player.repairCrew}→${effective}, ~${approxPerSec} HP/s out of combat)`;
    }
  }

  return { desc, blocked };
}

function addGold(amount) {
  state.gold += amount;
  state.xp += amount;
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level += 1;
    state.xpToNext = Math.floor(state.xpToNext * 1.3 + 5);
    player.size += 0.6;
    player.maxHp += 2;
    player.hp = Math.min(player.maxHp, player.hp + 4);
    offerUpgrades();
  }
}

function vesselForward(entity) {
  return { x: Math.cos(entity.heading), y: Math.sin(entity.heading) };
}

function collisionRadius(entity) {
  return entity.size * 0.72;
}

function vesselImpactPower(entity, normalX, normalY) {
  const fwd = vesselForward(entity);
  const bowDot = Math.max(0, fwd.x * normalX + fwd.y * normalY);
  const ramBonus = entity.ram ? 1.4 : (entity.kind === 'rammer' ? 1.24 : 1);
  return entity.speed * entity.mass * (0.78 + bowDot * 0.72) * ramBonus;
}

function resolveVesselCollision(a, b, dt) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const d = Math.hypot(dx, dy) || 0.0001;
  const minDist = collisionRadius(a) + collisionRadius(b);
  if (d >= minDist) return;

  const nx = dx / d;
  const ny = dy / d;
  const overlap = minDist - d;

  const massA = Math.max(1, a.mass);
  const massB = Math.max(1, b.mass);
  const totalMass = massA + massB;
  a.x -= nx * overlap * (massB / totalMass);
  a.y -= ny * overlap * (massB / totalMass);
  b.x += nx * overlap * (massA / totalMass);
  b.y += ny * overlap * (massA / totalMass);

  a.x = clamp(a.x, 24, state.world.width - 24);
  a.y = clamp(a.y, 24, state.world.height - 24);
  b.x = clamp(b.x, 24, state.world.width - 24);
  b.y = clamp(b.y, 24, state.world.height - 24);

  const va = vesselForward(a);
  const vb = vesselForward(b);
  const relNormalSpeed = (va.x * a.speed - vb.x * b.speed) * nx + (va.y * a.speed - vb.y * b.speed) * ny;
  if (relNormalSpeed <= 0) return;

  const restitution = 0.2;
  const impulse = (1 + restitution) * relNormalSpeed / (1 / massA + 1 / massB);
  a.speed = Math.max(0, a.speed - (impulse / massA) * 0.46);
  b.speed = Math.max(0, b.speed - (impulse / massB) * 0.46);

  a.heading += (-ny * 0.012) + (Math.random() - 0.5) * 0.016;
  b.heading += (ny * 0.012) + (Math.random() - 0.5) * 0.016;

  a.impactTimer = Math.max(0, (a.impactTimer || 0) - dt);
  b.impactTimer = Math.max(0, (b.impactTimer || 0) - dt);

  if ((a.impactTimer || 0) <= 0) {
    const impactOnA = vesselImpactPower(b, -nx, -ny);
    const dmgA = Math.max(0, impactOnA * 0.00074 - massA * 0.007);
    if (a === player) damagePlayer(dmgA);
    else a.hp -= dmgA;
    a.impactTimer = 0.2;
  }

  if ((b.impactTimer || 0) <= 0) {
    const impactOnB = vesselImpactPower(a, nx, ny);
    const dmgB = Math.max(0, impactOnB * 0.00074 - massB * 0.007);
    if (b === player) damagePlayer(dmgB);
    else b.hp -= dmgB;
    b.impactTimer = 0.2;
  }
}

function drawHullBody(size, hullColor, trimColor, profile, ramEnabled = false) {
  const shape = getHullShape({
    size,
    hullLength: profile.hullLength,
    hullBeam: profile.hullBeam,
    bowSharpness: profile.bowSharpness,
    sternTaper: profile.sternTaper
  });
  const { len, beam, bowX, shoulderX, sternShoulderX, sternX } = shape;

  ctx.fillStyle = hullColor;
  ctx.beginPath();
  ctx.moveTo(bowX, 0);
  ctx.lineTo(shoulderX, -beam * 0.62);
  ctx.lineTo(sternShoulderX, -beam * 0.46);
  ctx.lineTo(sternX, 0);
  ctx.lineTo(sternShoulderX, beam * 0.46);
  ctx.lineTo(shoulderX, beam * 0.62);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = trimColor;
  ctx.beginPath();
  ctx.moveTo(bowX * 0.82, 0);
  ctx.lineTo(shoulderX * 0.78, -beam * 0.44);
  ctx.lineTo(sternShoulderX * 0.72, -beam * 0.3);
  ctx.lineTo(sternX * 0.74, 0);
  ctx.lineTo(sternShoulderX * 0.72, beam * 0.3);
  ctx.lineTo(shoulderX * 0.78, beam * 0.44);
  ctx.closePath();
  ctx.fill();

  if (ramEnabled) {
    ctx.fillStyle = '#bdb7b0';
    ctx.beginPath();
    ctx.moveTo(bowX, -4);
    ctx.lineTo(bowX + 12, 0);
    ctx.lineTo(bowX, 4);
    ctx.closePath();
    ctx.fill();
  }

  return shape;
}

window.addEventListener('keydown', (e) => {
  if (!state.upgradesOffered) return;
  const key = e.key;
  const idx = key === '1' ? 0 : key === '2' ? 1 : key === '3' ? 2 : -1;
  if (idx >= 0 && state.upgradesOffered.options[idx]) {
    state.upgradesOffered.options[idx].apply();
    state.upgradesOffered = null;
  }
});

function update(dt) {
  if (state.gameOver) return;
  if (state.upgradesOffered) return;
  clampPlayerCrewToDeck();
  clampPlayerSupportCrewToDeck();
  clampPlayerArmamentToHull();

  state.time += dt;
  player.impactTimer = Math.max(0, (player.impactTimer || 0) - dt);
  player.repairSuppressed = Math.max(0, (player.repairSuppressed || 0) - dt);

  const cfg = getLevelConfig(state.stageIndex);
  state.stageTimer += dt;
  state.bossTimer += dt;

  if (state.stageTimer >= cfg.duration) {
    state.stageTimer = 0;
    if (ENDLESS_MODE || state.stageIndex < LEVEL_CONFIGS.length - 1) {
      state.stageIndex += 1;
    }
  }

  const hasBossAlive = state.enemies.some((e) => e.kind === 'boss');
  if (state.bossTimer >= cfg.bossEvery && !hasBossAlive) {
    state.bossTimer = 0;
    spawnBoss();
  }

  state.wind.timer += dt;
  if (state.wind.timer > cfg.windShift) {
    state.wind.timer = 0;
    const angle = Math.random() * Math.PI * 2;
    const strength = 0.2 + Math.random() * 0.35;
    state.wind.x = Math.cos(angle) * strength;
    state.wind.y = Math.sin(angle) * strength;
  }

  const forwardPressed = keys.has('w') || keys.has('arrowup');
  const brakePressed = keys.has('s') || keys.has('arrowdown');
  const turnLeft = keys.has('a') || keys.has('arrowleft');
  const turnRight = keys.has('d') || keys.has('arrowright');

  const fwd = getForwardVector();
  const windMag = Math.hypot(state.wind.x, state.wind.y) || 1;
  const windDir = { x: state.wind.x / windMag, y: state.wind.y / windMag };

  const rowPower = forwardPressed ? (0.14 + player.rowers * 0.075) : 0;
  state.rowEffort = clamp(rowPower / 0.55, 0, 1);
  const sailAlignment = player.sailOpen ? Math.max(0, fwd.x * windDir.x + fwd.y * windDir.y) : 0;
  const sailPush = player.sailOpen ? sailAlignment * (0.11 + player.size * 0.0018) : 0;
  const drag = brakePressed ? 0.06 : 0.018;
  const pace = dt * 12;

  const inertia = 1 + Math.max(0, (player.mass - 28) / 44);
  const accel = (rowPower + sailPush) / Math.max(1, player.mass / 16) / inertia;
  player.speed += accel * pace;
  player.speed -= drag * player.speed * pace;
  player.speed = Math.max(0, Math.min(player.baseSpeed + 1.9, player.speed));

  const steerAuthorityBase = 0.012 + player.rudder * 0.006 + player.rowers * 0.002;
  const steerAuthority = steerAuthorityBase / (1 + Math.max(0, (player.mass - 28) / 40)) * (1 - player.maneuverPenalty);
  const speedFactor = 0.3 + Math.min(1.2, player.speed / 2.4);
  if (turnLeft) player.heading -= steerAuthority * speedFactor * pace;
  if (turnRight) player.heading += steerAuthority * speedFactor * pace;

  const rowerMitigation = Math.min(0.85, player.rowers * 0.16);
  const wx = state.wind.x * (1 - rowerMitigation);
  const wy = state.wind.y * (1 - rowerMitigation);

  player.x += fwd.x * player.speed * pace + wx * dt * 6;
  player.y += fwd.y * player.speed * pace + wy * dt * 6;
  applyShoreRepulsion(player, dt, 0.72);

  player.x = Math.max(24, Math.min(state.world.width - 24, player.x));
  player.y = Math.max(24, Math.min(state.world.height - 24, player.y));
  resolveIslandCollisions(player, dt, true);

  const zoomTarget = clamp(1 - (player.size - 16) * 0.008 + state.zoomUserOffset, 0.5, 1.6);
  state.zoom += (zoomTarget - state.zoom) * 0.09;
  state.difficultyFromSize = Math.floor(Math.max(0, (16 - state.zoom * 16) * 0.9));
  ensureIslandDefenses();
  updateCamera();

  player.gunTimer += dt;
  player.cannonTimer += dt;
  const firedPlayer = shootAtNearest();
  if (firedPlayer.firedGun) player.gunTimer = 0;
  if (firedPlayer.firedCannon) player.cannonTimer = 0;

  const difficultyMult = 1 + state.difficultyTier * 0.22 + state.stageIndex * 0.12 + state.difficultyFromSize * 0.09;
  const spawnChance = (0.0069 * cfg.spawnRate + state.level * 0.00013 + state.difficultyTier * 0.0002 + state.difficultyFromSize * 0.00025) * dt * 60;
  if (Math.random() < spawnChance) spawnEnemy();

  for (const bullet of state.bullets) {
    bullet.x += bullet.vx * dt * 60;
    bullet.y += bullet.vy * dt * 60;
  }
  state.bullets = state.bullets.filter(b => b.x > -30 && b.x < state.world.width + 30 && b.y > -30 && b.y < state.world.height + 30);

  function getEnemySteerTarget(enemy) {
    if (enemy.kind === 'boss' || enemy.kind === 'rammer') {
      return { x: player.x, y: player.y };
    }

    if (enemy.squadId != null) {
      let mates = 0;
      let cx = 0;
      let cy = 0;
      let alignX = 0;
      let alignY = 0;
      let sepX = 0;
      let sepY = 0;

      for (const ally of state.enemies) {
        if (ally === enemy || ally.squadId !== enemy.squadId) continue;
        const dx = ally.x - enemy.x;
        const dy = ally.y - enemy.y;
        const d = Math.hypot(dx, dy);
        if (d > 260) continue;

        mates += 1;
        cx += ally.x;
        cy += ally.y;
        alignX += Math.cos(ally.heading);
        alignY += Math.sin(ally.heading);

        if (d < enemy.size * 2.6) {
          const inv = 1 / Math.max(1, d);
          sepX -= dx * inv;
          sepY -= dy * inv;
        }
      }

      if (mates > 0) {
        cx /= mates;
        cy /= mates;
        const len = Math.hypot(alignX, alignY) || 1;
        const flank = enemy.kind === 'raider' ? 46 : 32;
        const flockTarget = {
          x: cx + (alignX / len) * flank + sepX * 8,
          y: cy + (alignY / len) * flank + sepY * 8
        };
        const attackWeight = enemy.kind === 'raider' ? 0.58 : 0.44;
        return {
          x: flockTarget.x * (1 - attackWeight) + player.x * attackWeight,
          y: flockTarget.y * (1 - attackWeight) + player.y * attackWeight
        };
      }
    }

    let bestAlly = null;
    let bestD2 = Infinity;
    const followRange = 220;
    for (const ally of state.enemies) {
      if (ally === enemy || ally.kind === 'boss' || ally.kind === 'rammer') continue;
      const dx = ally.x - enemy.x;
      const dy = ally.y - enemy.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < followRange * followRange && d2 < bestD2) {
        bestD2 = d2;
        bestAlly = ally;
      }
    }

    if (!bestAlly) return { x: player.x, y: player.y };

    if (enemy.kind === 'pirate') {
      return { x: bestAlly.x, y: bestAlly.y };
    }

    if (enemy.kind === 'raider') {
      const lead = 40;
      return {
        x: bestAlly.x + Math.cos(bestAlly.heading) * lead,
        y: bestAlly.y + Math.sin(bestAlly.heading) * lead
      };
    }

    return { x: player.x, y: player.y };
  }

  for (const enemy of state.enemies) {
    enemy.impactTimer = Math.max(0, (enemy.impactTimer || 0) - dt);
    const target = getEnemySteerTarget(enemy);
    const distToTarget = Math.hypot(target.x - enemy.x, target.y - enemy.y);
    const shoreAvoid = getShoreAvoidanceVector(enemy, 200);
    const vesselAvoid = getVesselSeparationVector(enemy);
    const steerTarget = {
      x: target.x + shoreAvoid.x * 160 + vesselAvoid.x * 220,
      y: target.y + shoreAvoid.y * 160 + vesselAvoid.y * 220
    };
    const avoidPressure = Math.hypot(vesselAvoid.x, vesselAvoid.y);

    simulateVessel(enemy, dt, {
      rowing: distToTarget > enemy.size * 2.4 && avoidPressure < 0.95,
      brake: avoidPressure > 1.12,
      turnLeft: angleDiff(Math.atan2(steerTarget.y - enemy.y, steerTarget.x - enemy.x), enemy.heading) < -0.03,
      turnRight: angleDiff(Math.atan2(steerTarget.y - enemy.y, steerTarget.x - enemy.x), enemy.heading) > 0.03
    });
    applyShoreRepulsion(enemy, dt, 0.9);
    resolveIslandCollisions(enemy, dt, false);

    enemy.gunTimer += dt;
    enemy.cannonTimer += dt;
    const canGun = enemy.gunTimer >= enemy.gunReload;
    const canCannon = enemy.cannonTimer >= enemy.cannonReload;
    if (canGun || canCannon) {
      const playerPlan = getBroadsideFirePlan(enemy, player);
      const chosen = enemy.kind === 'boss' ? pickBossTarget(enemy, playerPlan) : { target: player, plan: playerPlan };
      const allowGun = canGun && chosen.plan.dist <= enemy.gunRange && chosen.plan.canLikelyHitGun;
      const allowCannon = canCannon && chosen.plan.dist <= enemy.cannonRange && chosen.plan.canLikelyHitCannon;
      if (allowGun || allowCannon) {
        const fired = enemyVolley(enemy, chosen.target, chosen.plan.sideSign, chosen.plan.dist, allowGun, allowCannon);
        if (fired.firedGun) enemy.gunTimer = 0;
        if (fired.firedCannon) enemy.cannonTimer = 0;
      }
    }
  }

  for (let i = 0; i < state.enemies.length; i++) {
    resolveVesselCollision(player, state.enemies[i], dt);
  }

  for (let i = 0; i < state.enemies.length; i++) {
    for (let j = i + 1; j < state.enemies.length; j++) {
      resolveVesselCollision(state.enemies[i], state.enemies[j], dt);
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];

    for (let j = state.bullets.length - 1; j >= 0; j--) {
      const b = state.bullets[j];
      if (b.owner === 'enemy') {
        const bossFriendlyFire = b.sourceKind === 'boss' && b.shooterId !== enemy.id && enemy.kind !== 'boss';
        if (!bossFriendlyFire) continue;
      }
      const d = Math.hypot(enemy.x - b.x, enemy.y - b.y);
      if (d < enemy.size + 4) {
        const dmgScale = b.owner === 'enemy' ? 0.64 : 1;
        enemy.hp -= b.dmg * dmgScale;
        const n = normalizeOr(b.vx, b.vy, 1, 0);
        spawnImpactDebris(enemy.x, enemy.y, n.x, n.y, !!b.heavy, enemy);
        spawnDeckBurst(enemy.x, enemy.y, n.x, n.y, !!b.heavy);
        if (b.heavy) playCannonImpactSfx(enemy.x, enemy.y, n.x, n.y, b.sourceSize || 16);
        else playGunImpactSfx(enemy.x, enemy.y, n.x, n.y, b.sourceSize || 16);
        state.bullets.splice(j, 1);
        if (enemy.hp <= 0) {
          spawnShipExplosion(enemy.x, enemy.y, enemy.size, enemy.kind === 'boss');
          state.enemies.splice(i, 1);
          if (enemy.kind === 'boss') {
            state.difficultyTier += 1;
            state.bossesDefeated += 1;
            offerMajorUpgrades();
            state.drops.push({ x: enemy.x, y: enemy.y, v: 22 + Math.random() * 6 });
          } else {
            const bonus = enemy.kind === 'raider' ? 6 : 3;
            state.drops.push({ x: enemy.x, y: enemy.y, v: bonus + Math.random() * 2.5 });
          }
          break;
        }
      }
    }
  }

  for (const island of state.islands) {
    for (let i = island.buildings.length - 1; i >= 0; i--) {
      const building = island.buildings[i];
      for (let j = state.bullets.length - 1; j >= 0; j--) {
        const b = state.bullets[j];
        if (b.owner !== 'player') continue;
        const d = Math.hypot(building.x - b.x, building.y - b.y);
        if (d < building.size * 0.65 + 4) {
          const dmgScale = b.heavy ? 1.05 : 0.58;
          building.hp -= b.dmg * dmgScale;
          const n = normalizeOr(b.vx, b.vy, 1, 0);
          spawnImpactDebris(building.x, building.y, n.x, n.y, !!b.heavy, { hullColor: '#a77556', trimColor: '#7d593f' });
          if (b.heavy) playCannonImpactSfx(building.x, building.y, n.x, n.y, b.sourceSize || 16);
          else playGunImpactSfx(building.x, building.y, n.x, n.y, b.sourceSize || 16);
          state.bullets.splice(j, 1);
          if (building.hp <= 0) {
            const goldCount = Math.max(2, Math.floor(building.size / 4));
            for (let g = 0; g < goldCount; g++) {
              const radial = Math.atan2(building.y - island.y, building.x - island.x);
              const ang = radial + (Math.random() - 0.5) * 1.5;
              const dist = building.size * (0.15 + Math.random() * 0.7);
              const burst = 1.4 + Math.random() * 3.2;
              state.drops.push({
                x: building.x + Math.cos(ang) * dist,
                y: building.y + Math.sin(ang) * dist,
                v: 1 + building.size * 0.16 + Math.random() * 1.6,
                vx: Math.cos(ang) * burst,
                vy: Math.sin(ang) * burst
              });
            }
            island.buildings.splice(i, 1);
          }
          break;
        }
      }
    }

    const activeTowers = island.buildings.filter((b) => b.tower);
    for (const tower of activeTowers) {
      tower.fireTimer += dt;
      const cadence = Math.max(0.7, 1.6 - island.defenseLevel * 0.12);
      const batteryRange = getPlayerRanges().cannon;
      if (tower.fireTimer >= cadence) {
        const dxToPlayer = player.x - tower.x;
        const dyToPlayer = player.y - tower.y;
        const distToPlayer = Math.hypot(dxToPlayer, dyToPlayer);
        if (distToPlayer > batteryRange) continue;
        tower.fireTimer = 0;
        const ang = Math.atan2(player.y - tower.y, player.x - tower.x) + (Math.random() - 0.5) * 0.16;
        state.bullets.push({
          x: tower.x,
          y: tower.y,
          vx: Math.cos(ang) * 4.2,
          vy: Math.sin(ang) * 4.2,
          dmg: 5 + island.defenseLevel * 1.5,
          heavy: true,
          owner: 'enemy',
          sourceSize: Math.max(14, tower.size * 0.9)
        });
      }
    }
  }

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const enemy = state.enemies[i];
    if (enemy.hp <= 0) {
      spawnShipExplosion(enemy.x, enemy.y, enemy.size, enemy.kind === 'boss');
      state.enemies.splice(i, 1);
      if (enemy.kind === 'boss') {
        state.difficultyTier += 1;
        state.bossesDefeated += 1;
        offerMajorUpgrades();
        state.drops.push({ x: enemy.x, y: enemy.y, v: 22 + Math.random() * 6 });
      } else {
        const bonus = enemy.kind === 'raider' ? 6 : 3;
        state.drops.push({ x: enemy.x, y: enemy.y, v: bonus + Math.random() * 2.5 });
      }
    }
  }

  for (let i = state.bullets.length - 1; i >= 0; i--) {
    const b = state.bullets[i];
    if (b.owner !== 'enemy') continue;
    const d = Math.hypot(player.x - b.x, player.y - b.y);
    if (d < player.size * 0.78 + 4) {
      damagePlayer(b.dmg * (b.heavy ? 0.28 : 0.18));
      const n = normalizeOr(b.vx, b.vy, 1, 0);
      spawnImpactDebris(player.x, player.y, n.x, n.y, !!b.heavy, player);
      spawnDeckBurst(player.x, player.y, n.x, n.y, !!b.heavy);
      if (b.heavy) playCannonImpactSfx(player.x, player.y, n.x, n.y, b.sourceSize || 16);
      else playGunImpactSfx(player.x, player.y, n.x, n.y, b.sourceSize || 16);
      state.bullets.splice(i, 1);
    }
  }

  for (let i = state.drops.length - 1; i >= 0; i--) {
    const d = state.drops[i];

    d.vx = d.vx || 0;
    d.vy = d.vy || 0;
    d.x += d.vx * dt * 60;
    d.y += d.vy * dt * 60;
    d.vx *= 0.92;
    d.vy *= 0.92;

    d.x = clamp(d.x, 16, state.world.width - 16);
    d.y = clamp(d.y, 16, state.world.height - 16);

    const dx = player.x - d.x;
    const dy = player.y - d.y;
    const dist = Math.hypot(dx, dy) || 1;
    const magnetRange = getPlayerRanges().gun * GOLD_MAGNET_PULL_FACTOR;
    if (dist < magnetRange) {
      const pull = GOLD_MAGNET_BASE_SPEED + (1 - dist / magnetRange) * 5.4;
      d.x += (dx / dist) * pull * dt * 60;
      d.y += (dy / dist) * pull * dt * 60;
    }
    if (dist < 16) {
      addGold(d.v);
      state.drops.splice(i, 1);
    }
  }

  for (const p of state.particles) {
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.y -= p.drift * dt * 60;
    p.rot += p.spin;
    p.life -= dt;
  }
  state.particles = state.particles.filter((p) => p.life > 0);

  for (const cloud of state.clouds) {
    cloud.x += (state.wind.x * 0.35 + cloud.drift) * dt * 60;
    cloud.y += (state.wind.y * 0.2) * dt * 60;
    if (cloud.x > state.world.width + 200) cloud.x = -220;
    if (cloud.x < -240) cloud.x = state.world.width + 180;
    if (cloud.y > state.world.height + 120) cloud.y = -120;
    if (cloud.y < -120) cloud.y = state.world.height + 120;
  }

  if (player.hp > 0 && player.hp < player.maxHp && (player.repairCrew || 0) > 0) {
    const movementPenalty = clamp(player.speed / Math.max(0.1, player.baseSpeed + 1.2), 0, 1);
    const suppression = clamp((player.repairSuppressed || 0) / 2.4, 0, 1);
    const regenPerSec = 0.36 + player.repairCrew * 0.3;
    const regenScale = (1 - suppression) * (1 - movementPenalty * 0.45);
    if (regenScale > 0) {
      player.hp = Math.min(player.maxHp, player.hp + regenPerSec * regenScale * dt);
    }
  }

  if (player.hp <= 0) {
    player.hp = 0;
    state.gameOver = true;
  }
}

function drawShip() {
  const s = player.size;
  ctx.save();
  const pos = toScreen(player.x, player.y);
  ctx.translate(pos.x, pos.y);
  ctx.rotate(player.heading);
  ctx.scale(state.zoom, state.zoom);

  const hull = drawHullBody(s, player.hullColor, player.trimColor, player, player.ram);
  const sLen = hull.len;
  const sBeam = hull.beam;

  ctx.fillStyle = player.trimColor;
  const mast = Math.max(8, s * 1.2 * player.mastScale);
  ctx.fillRect(-2, -mast, 4, mast);

  if (player.sailOpen) {
    ctx.fillStyle = player.sailColor;
    ctx.beginPath();
    ctx.moveTo(2, -mast + 2);
    ctx.lineTo(s * 1.1, -mast * 0.65);
    ctx.lineTo(2, -mast * 0.3);
    ctx.closePath();
    ctx.fill();
  }

  const crewCount = Math.min(player.crew, getDeckCrewCapacity(player));
  ctx.fillStyle = '#1f2f3a';
  const crewCols = Math.max(1, Math.ceil(Math.sqrt(crewCount * 1.2)));
  const crewRows = Math.max(1, Math.ceil(crewCount / crewCols));
  const crewSpanX = Math.min(sLen * 0.72, 8 + crewCols * 3.2);
  const crewSpanY = Math.min(sBeam * 0.95, 7 + crewRows * 3.0);
  const stepX = crewCols <= 1 ? 0 : crewSpanX / (crewCols - 1);
  const stepY = crewRows <= 1 ? 0 : crewSpanY / (crewRows - 1);
  for (let i = 0; i < crewCount; i++) {
    const col = i % crewCols;
    const row = Math.floor(i / crewCols);
    const px = (col - (crewCols - 1) / 2) * stepX - sLen * 0.02;
    let py = (row - (crewRows - 1) / 2) * stepY;
    const hw = hullHalfWidthAt(hull, px) * 0.72;
    py = clamp(py, -hw, hw);
    ctx.beginPath();
    ctx.arc(px, py, 2.2, 0, Math.PI * 2);
    ctx.fill();
  }

  drawDeckDamageMarks(player, hull, 1);

  const broadsidePorts = Math.max(2, player.gunners + player.cannons);
  const cannonPorts = Math.min(broadsidePorts, player.cannons);
  const cannonMask = getDistributedCannonMask(broadsidePorts, cannonPorts);
  const aim = state.playerAim;
  const targetLocalAngle = aim ? angleDiff(aim.targetAngle, player.heading) : null;
  const pivotRad = player.cannonPivot * (Math.PI / 180);
  for (let i = 0; i < broadsidePorts; i++) {
    const cannonPort = cannonMask[i];
    const length = cannonPort ? Math.max(8, s * 0.48) : Math.max(4.5, s * 0.3);
    const thickness = cannonPort ? Math.max(2.8, s * 0.14) : Math.max(1.8, s * 0.1);
    const color = cannonPort ? '#5f656c' : '#d5dbe2';
    const portMount = getHullSideMount(hull, i, broadsidePorts, -1, 0.12, 0.88);
    const starboardMount = getHullSideMount(hull, i, broadsidePorts, 1, 0.12, 0.88);

    let portAim = 0;
    let starAim = 0;
    if (cannonPort && aim && targetLocalAngle !== null) {
      const portBase = Math.atan2(portMount.ny, portMount.nx);
      const starBase = Math.atan2(starboardMount.ny, starboardMount.nx);
      if (aim.sideSign < 0) portAim = clamp(angleDiff(targetLocalAngle, portBase), -pivotRad, pivotRad);
      if (aim.sideSign > 0) starAim = clamp(angleDiff(targetLocalAngle, starBase), -pivotRad, pivotRad);
    }

    drawPerimeterMountWithAim(portMount, length, thickness, color, portAim);
    drawPerimeterMountWithAim(starboardMount, length, thickness, color, starAim);
  }

  ctx.restore();
}

function drawEnemyShip(enemy) {
  const s = enemy.size;
  const pos = toScreen(enemy.x, enemy.y);
  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(enemy.heading);
  ctx.scale(state.zoom, state.zoom);

  const hull = drawHullBody(s, enemy.hullColor, '#b8997a', enemy, false);
  const sLen = hull.len;
  const sBeam = hull.beam;

  ctx.fillStyle = '#b8997a';
  ctx.fillRect(-1.5, -s * 1.12, 3, s * 1.12);

  if (enemy.sailOpen) {
    ctx.fillStyle = enemy.sailColor;
    ctx.beginPath();
    ctx.moveTo(2, -s * 1.12);
    ctx.lineTo(s * 0.95, -s * 0.76);
    ctx.lineTo(2, -s * 0.45);
    ctx.closePath();
    ctx.fill();
  }

  const flagBaseX = 2;
  const flagTop = -s * 1.08;
  const flagLen = Math.max(7, s * 0.55);
  const flagH = Math.max(5, s * 0.28);
  ctx.fillStyle = enemy.flagColor || '#a65a43';
  ctx.beginPath();
  ctx.moveTo(flagBaseX, flagTop);
  ctx.lineTo(flagBaseX + flagLen, flagTop + flagH * 0.48);
  ctx.lineTo(flagBaseX, flagTop + flagH);
  ctx.closePath();
  ctx.fill();

  const stripes = clamp(enemy.flagStripes || 1, 1, 5);
  ctx.fillStyle = enemy.flagAccent || '#f4d7b0';
  for (let i = 0; i < stripes; i++) {
    const t = (i + 1) / (stripes + 1);
    const x = flagBaseX + t * (flagLen * 0.74);
    const y1 = flagTop + t * 0.35;
    const y2 = flagTop + flagH - t * 0.35;
    ctx.fillRect(x, y1, Math.max(1.1, s * 0.05), Math.max(1.6, y2 - y1));
  }

  if (enemy.squadId != null) {
    ctx.fillStyle = '#f9fff6';
    const dotX = flagBaseX + flagLen * 0.32;
    const dotY = flagTop + flagH * 0.5;
    ctx.beginPath();
    ctx.arc(dotX, dotY, Math.max(1.1, s * 0.05), 0, Math.PI * 2);
    ctx.fill();
  }

  drawDeckDamageMarks(enemy, hull, 0.95);

  const gunPorts = Math.max(1, enemy.gunners);
  for (let i = 0; i < gunPorts; i++) {
    const portMount = getHullSideMount(hull, i, gunPorts, -1, 0.12, 0.88);
    const starboardMount = getHullSideMount(hull, i, gunPorts, 1, 0.12, 0.88);
    drawPerimeterMount(portMount, Math.max(3.8, s * 0.27), Math.max(1.7, s * 0.1), '#d0d6de');
    drawPerimeterMount(starboardMount, Math.max(3.8, s * 0.27), Math.max(1.7, s * 0.1), '#d0d6de');
  }

  for (let i = 0; i < enemy.cannons; i++) {
    const portMount = getHullSideMount(hull, i, enemy.cannons, -1, 0.16, 0.84);
    const starboardMount = getHullSideMount(hull, i, enemy.cannons, 1, 0.16, 0.84);
    drawPerimeterMount(portMount, Math.max(6.6, s * 0.42), Math.max(2.5, s * 0.13), '#596068');
    drawPerimeterMount(starboardMount, Math.max(6.6, s * 0.42), Math.max(2.5, s * 0.13), '#596068');
  }

  ctx.restore();
}

function drawWorld() {
  const camX = state.camera.x;
  const camY = state.camera.y;
  const z = state.zoom;
  const viewW = canvas.width / z;
  const viewH = canvas.height / z;

  const tile = 16;
  const startX = Math.floor(camX / tile) * tile;
  const startY = Math.floor(camY / tile) * tile;
  for (let worldY = startY; worldY < camY + viewH + tile; worldY += tile) {
    for (let worldX = startX; worldX < camX + viewW + tile; worldX += tile) {
      const pattern = ((Math.floor(worldX / tile) + Math.floor(worldY / tile)) % 2 === 0);
      ctx.fillStyle = pattern ? '#0a2e45' : '#0b334d';
      ctx.fillRect((worldX - camX) * z, (worldY - camY) * z, tile * z + 1, tile * z + 1);
    }
  }

  ctx.strokeStyle = 'rgba(132,188,220,0.16)';
  for (let y = 0; y < canvas.height; y += 20 * z) {
    const worldY = camY + y / z;
    ctx.beginPath();
    ctx.moveTo(0, y + Math.sin((state.time * 1.4) + worldY * 0.03) * 2 * z);
    ctx.lineTo(canvas.width, y + Math.sin((state.time * 1.4) + worldY * 0.03) * 2 * z);
    ctx.stroke();
  }

  for (const island of state.islands) {
    const sx = (island.x - camX) * z;
    const sy = (island.y - camY) * z;
    const sr = island.r * z;
    if (sx < -sr - 40 || sx > canvas.width + sr + 40 || sy < -sr - 40 || sy > canvas.height + sr + 40) continue;

    for (const patch of island.patches) {
      const px = (patch.x - camX) * z;
      const py = (patch.y - camY) * z;
      const pr = patch.size * z;
      ctx.fillStyle = patch.sides === 6 ? '#b2a46f' : '#a69663';
      polygonPath(px, py, pr, patch.sides, patch.rot);
      ctx.fill();
      ctx.fillStyle = patch.sides === 6 ? '#6e9d4b' : '#6a9349';
      polygonPath(px, py, pr * 0.62, patch.sides, patch.rot + 0.08);
      ctx.fill();
    }

    for (const dock of island.docks) {
      const dp = toScreen(dock.x, dock.y);
      ctx.save();
      ctx.translate(dp.x, dp.y);
      ctx.rotate(dock.rot);
      const dl = dock.length * z;
      const dw = dock.width * z;
      ctx.fillStyle = '#7a5435';
      ctx.fillRect(0, -dw * 0.5, dl, dw);
      ctx.fillStyle = '#8c6542';
      for (let p = 2; p < dl; p += Math.max(3, 4 * z)) {
        ctx.fillRect(p, -dw * 0.5, 1 * z + 0.6, dw);
      }
      ctx.fillStyle = '#604229';
      const postW = Math.max(1, 1.4 * z);
      const postH = Math.max(2, 2.5 * z);
      ctx.fillRect(1, -dw * 0.5 - postH, postW, postH);
      ctx.fillRect(1, dw * 0.5, postW, postH);
      ctx.fillRect(dl - 2, -dw * 0.5 - postH, postW, postH);
      ctx.fillRect(dl - 2, dw * 0.5, postW, postH);
      ctx.restore();
    }

    for (const building of island.buildings) {
      const bp = toScreen(building.x, building.y);
      const bw = building.size * 0.9 * z;
      const bh = building.size * z;
      ctx.fillStyle = 'rgba(12,16,22,0.22)';
      ctx.fillRect(bp.x - bw * 0.46, bp.y + bh * 0.44, bw * 0.92, bh * 0.16);

      ctx.fillStyle = building.tower ? '#7e8f9e' : '#ba8a63';
      ctx.fillRect(bp.x - bw * 0.5, bp.y - bh * 0.55, bw, bh);

      ctx.fillStyle = building.tower ? '#97a8b8' : '#cf9a70';
      ctx.fillRect(bp.x - bw * 0.45, bp.y - bh * 0.49, bw * 0.9, bh * 0.12);

      ctx.fillStyle = building.tower ? '#4f5d69' : '#8d5f40';
      ctx.fillRect(bp.x - bw * 0.22, bp.y - bh * 0.9, bw * 0.44, bh * 0.34);

      ctx.fillStyle = building.tower ? '#cfd9e4' : '#f2d2a8';
      ctx.fillRect(bp.x - bw * 0.08, bp.y - bh * 0.14, bw * 0.16, bh * 0.18);
      if (!building.tower) {
        ctx.fillRect(bp.x - bw * 0.3, bp.y - bh * 0.08, bw * 0.12, bh * 0.12);
        ctx.fillRect(bp.x + bw * 0.18, bp.y - bh * 0.08, bw * 0.12, bh * 0.12);
      }
    }
  }
}

function drawCloudOverlay() {
  const z = state.zoom;
  for (const cloud of state.clouds) {
    const sx = (cloud.x - state.camera.x) * z;
    const sy = (cloud.y - state.camera.y) * z;
    const cw = cloud.w * z;
    const ch = cloud.h * z;
    if (sx < -260 || sx > canvas.width + 260 || sy < -160 || sy > canvas.height + 160) continue;
    ctx.fillStyle = 'rgba(210,225,236,0.14)';
    ctx.fillRect(sx, sy, cw, ch);
    ctx.fillRect(sx + cw * 0.2, sy - ch * 0.35, cw * 0.6, ch * 0.45);
    ctx.fillRect(sx + cw * 0.15, sy + ch * 0.62, cw * 0.5, ch * 0.3);
  }
}

function drawHud() {
  const hpRatio = clamp(player.hp / player.maxHp, 0, 1);
  const gunLoad = clamp(player.gunTimer / player.gunReload, 0, 1);
  const cannonLoad = clamp(player.cannonTimer / player.cannonReload, 0, 1);
  const stageLabel = getLevelConfig(state.stageIndex).name;
  const modeLabel = ENDLESS_MODE ? 'Endless' : 'Campaign';
  const bossIn = Math.max(0, Math.round(getLevelConfig(state.stageIndex).bossEvery - state.bossTimer));
  const caps = getShipWeaponCaps(player, player.cannonCapacityBonus);

  const panelW = Math.min(560, canvas.width * 0.62);
  const panelX = (canvas.width - panelW) / 2;
  const panelY = 12;
  const barW = panelW - 116;
  const barH = 12;
  const labelX = panelX + 14;
  const barX = panelX + 88;

  ctx.fillStyle = 'rgba(8,20,30,0.68)';
  ctx.fillRect(panelX, panelY, panelW, 116);

  ctx.fillStyle = '#e2f3ff';
  ctx.font = '12px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(`${modeLabel} · ${stageLabel} · Lv ${state.level} · Gold ${Math.round(state.gold)} · Boss ${bossIn}s`, panelX + panelW / 2, panelY + 16);
  ctx.fillText(`Wind ${windDirectionLabel()} · Speed ${player.speed.toFixed(2)} · Row ${Math.round(state.rowEffort * 100)}% · Guns ${player.gunners}/${caps.maxGunners} · Cannons ${player.cannons}/${caps.maxCannonsPerSide} per side · Repair ${player.repairCrew} · Tier ${caps.tier} · Pivot ${player.cannonPivot}° · Crew ${player.crew}/${getDeckCrewCapacity(player)} (free ${getSpareCrewCapacity(player)})`, panelX + panelW / 2, panelY + 32);

  ctx.textAlign = 'left';
  ctx.fillStyle = '#d8eefc';
  ctx.fillText('HULL', labelX, panelY + 53);
  ctx.fillText('GUN', labelX, panelY + 75);
  ctx.fillText('CANNON', labelX, panelY + 97);

  ctx.fillStyle = '#233746';
  ctx.fillRect(barX, panelY + 42, barW, barH);
  ctx.fillRect(barX, panelY + 64, barW, barH);
  ctx.fillRect(barX, panelY + 86, barW, barH);

  ctx.fillStyle = '#cd5454';
  ctx.fillRect(barX, panelY + 42, barW * hpRatio, barH);
  ctx.fillStyle = '#8fcfe4';
  ctx.fillRect(barX, panelY + 64, barW * gunLoad, barH);
  ctx.fillStyle = '#d8a167';
  ctx.fillRect(barX, panelY + 86, barW * cannonLoad, barH);

  ctx.fillStyle = '#ecf7ff';
  ctx.fillText(`${Math.round(player.hp)}/${player.maxHp}`, barX + barW + 8, panelY + 53);
  ctx.fillText(`${Math.round(gunLoad * 100)}%`, barX + barW + 8, panelY + 75);
  ctx.fillText(`${Math.round(cannonLoad * 100)}%`, barX + barW + 8, panelY + 97);
}

function drawRangeIndicators() {
  const pos = toScreen(player.x, player.y);
  const ranges = getPlayerRanges();

  ctx.save();
  ctx.strokeStyle = 'rgba(189,226,248,0.62)';
  ctx.lineWidth = 1.2;
  ctx.setLineDash([3, 6]);
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, ranges.gun * state.zoom, 0, Math.PI * 2);
  ctx.stroke();

  if (player.cannons > 0) {
    ctx.strokeStyle = 'rgba(232,191,142,0.64)';
    ctx.lineWidth = 2.3;
    ctx.setLineDash([12, 9]);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, ranges.cannon * state.zoom, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}

function windDirectionLabel() {
  const a = Math.atan2(state.wind.y, state.wind.x);
  const dirs = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
  const idx = Math.round(((a + Math.PI) / (Math.PI * 2)) * 8) % 8;
  return dirs[idx];
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWorld();
  drawRangeIndicators();

  drawShip();

  for (const b of state.bullets) {
    ctx.fillStyle = b.owner === 'enemy' ? (b.heavy ? '#f59b80' : '#f8baa5') : (b.heavy ? '#f1b05f' : '#ffd887');
    ctx.beginPath();
    const bp = toScreen(b.x, b.y);
    ctx.arc(bp.x, bp.y, (b.heavy ? 3.4 : 2.6) * state.zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  for (const d of state.drops) {
    const dp = toScreen(d.x, d.y);
    const spin = Math.cos(state.time * 7 + d.x * 0.03 + d.y * 0.04);
    const rx = Math.max(1, 4 * Math.abs(spin) * state.zoom);
    const ry = 4 * state.zoom;
    ctx.fillStyle = '#ffdd55';
    ctx.fillRect(dp.x - rx, dp.y - ry, rx * 2, ry * 2);
    ctx.fillStyle = '#fff3b5';
    ctx.fillRect(dp.x - rx * 0.25, dp.y - ry * 0.9, rx * 0.5, ry * 1.8);
  }

  for (const p of state.particles) {
    const life = clamp(p.life / p.maxLife, 0, 1);
    const pp = toScreen(p.x, p.y);
    const pr = p.size * (0.45 + life * 0.75) * state.zoom;
    ctx.save();
    ctx.translate(pp.x, pp.y);
    ctx.rotate(p.rot);
    ctx.globalAlpha = life;
    ctx.fillStyle = p.color;
    polygonPath(0, 0, pr, p.sides, 0);
    ctx.fill();
    ctx.restore();
  }

  for (const e of state.enemies) {
    drawEnemyShip(e);

    if (e.kind === 'boss') {
      const ep = toScreen(e.x, e.y);
      ctx.fillStyle = '#f3c8d0';
      ctx.fillRect(ep.x - e.size * 0.6 * state.zoom, ep.y - (e.size + 10) * state.zoom, e.size * 1.2 * state.zoom, 6 * state.zoom);
      ctx.fillStyle = '#d74662';
      const hpRatio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      ctx.fillRect(ep.x - e.size * 0.6 * state.zoom, ep.y - (e.size + 10) * state.zoom, e.size * 1.2 * hpRatio * state.zoom, 6 * state.zoom);
    }
  }

  drawCloudOverlay();

  if (state.upgradesOffered) {
    const cardW = Math.min(560, canvas.width * 0.68);
    const cardX = (canvas.width - cardW) / 2;
    const titleX = canvas.width / 2;
    ctx.fillStyle = 'rgba(5,10,15,0.78)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f5fbff';
    ctx.font = '24px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(state.upgradesOffered.title, titleX, 120);
    ctx.font = '18px system-ui';
    state.upgradesOffered.options.forEach((u, i) => {
      const cardInfo = getUpgradeCardInfo(u);
      const y = 200 + i * 95;
      if (state.upgradesOffered.major) {
        ctx.fillStyle = '#4a2f18';
      } else {
        ctx.fillStyle = cardInfo.blocked ? '#3a2b2b' : '#163349';
      }
      ctx.fillRect(cardX, y - 34, cardW, 62);
      ctx.fillStyle = cardInfo.blocked ? '#ffd6ba' : '#e8f5ff';
      ctx.textAlign = 'left';
      ctx.fillText(`${i + 1}) ${u.name}`, cardX + 22, y - 7);
      ctx.fillStyle = cardInfo.blocked ? '#f4b09a' : '#a8c6d9';
      ctx.fillText(cardInfo.desc, cardX + 22, y + 18);
    });
    ctx.textAlign = 'left';
  }

  if (state.gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '40px system-ui';
    ctx.fillText('Ship Sunk', 390, 250);
    ctx.font = '20px system-ui';
    ctx.fillText('Refresh to sail again', 392, 290);
  }

  statsEl.textContent = '';
  windEl.textContent = '';

  drawHud();

  ctx.save();
  ctx.translate(canvas.width - 78, 76);
  ctx.strokeStyle = 'rgba(220,242,255,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI * 2);
  ctx.stroke();
  const wx = state.wind.x;
  const wy = state.wind.y;
  const len = Math.hypot(wx, wy) || 1;
  const ax = (wx / len) * 22;
  const ay = (wy / len) * 22;
  ctx.strokeStyle = '#d6ecff';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(ax, ay);
  ctx.stroke();
  ctx.fillStyle = '#d6ecff';
  ctx.fillRect(ax - 2, ay - 2, 4, 4);
  ctx.restore();
}

let last = performance.now();
initWorld();
function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
